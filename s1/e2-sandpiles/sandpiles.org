#+title: sandpiles

* DONE setup                                                    :stage:
#+begin_src j
erase_sandpaint_ nl_sandpaint_''
erase_sandpiles_ nl_sandpiles_''
erase_sandcalc_ nl_sandcalc_''
erase_gridpad_ nl_gridpad_''
cocurrent'base'

NB. have inheritance image positioned and minimized.
#+end_src

* DONE 0. demo
# on stage: the 512 grain-in-the-center sandpile, copied to buffer.
# pen =: 1, grid off, timer off, focus in window!
What you're looking at here is called a sandpile.
# toggle grid
It's a two dimensional grid.
Each square contains zero or more grains of sand, indicated by the color.

# start drawing
If you have 0, 1, 2 or 3 grains, the pile is stable.
But as soon as you get to four grains, the sand topples over
sending one grain to each of the four neighboring cells.

# draw by the edge
If you have a four next to the edge of the board,
the same thing happens,
but one of the grains falls off the edge.
# .. and corner
Similarly, if you have a four in the corner, then two grains fall off.

# draw line of 3 at bottom
If you have a bunch of threes in a row,
and put a four next to it,
then when the four topples,
it adds a grain to the three,
giving you a new four
and then that one topples,
and you get a chain reaction.
# put mouse in center and press z to clear screen
And if you start with a bigger number number, (say 256),
then it will just keep pumping out four grains at each step.

# space a few times until zthe four neighbors pile up
So after four ticks, we have four piles of four, plus 240 grains left in the center.
All four of these topple,
and then the center keeps pumping out more.
# step until we get the diagonals
Now we have four cells with with one grain in them,
but each one has three neighbors that are about to topple.
So each of these ones will turn into fours.
# step
And each time the four surrounding the center topple,
the center sends out four,
but they simultaneously send four back
so for that particular step in the process,
the number in the center doesn't change.
# press 4

Anyway it goes on like that, and there's a little bit of back and forth
but before long the whole thing always winds down and comes to a stop.
# (fast forward)

The picture we started with was the same thing with 512 grains.

So as you can see, with just this one simple rule,
you start generating really intricate patterns rather quickly.
and it's kind of fun to just draw a pattern,
let it run, and see what comes out.

Depending on how you start you might get a nice pretty picture like this,
or if you just start pouring sand
# speed 3, then draw with pen 64
.. fast forward a bit...
# (fast forward)
you might just get a mess.

So that's sandpiles.

* DONE 0a. preview
#+begin_src j
Note 'topics'
  - sandpaint
  - sandpile paper
  - sandcalc
)
#+end_src

Now that you know the basics of sandpiles,
we're going to take a look at how to implement
the rules on a computer, by looking at the
drawing program you just saw.

We're also going to take a look at the original
paper to see why these were first invented.

Finally, we're going to look at a kind of
addition you can do with sandpiles. It also
makes kind of a neat puzzle game,
so stay tuned for that.

Let's get started.

* [8/8] 1. sandpiles
#+begin_src j

NB. (title card: sandpiles)

#+end_src
** DONE gridpad
#+begin_src j
load '~JTalks/s1/e2-sandpiles/gridpad.ijs'

echo names_gridpad_''

gpw_init_gridpad_''
#+end_src

I made this little drawing program in a previous video,
and I'm going to reuse it here just so we have a nice
way to view and edit our sandpiles.

You don't need to have seen that video to understand
this one, but if you did see it, the basic ideas haven't
changed, but you might notice I've renamed some things
and refactored a bit, mostly breaking out configuration
variables. There's a link to a full changelog on github
in the video description.

Anyway, starting from what we have here, you're going to
see every line of code. And fair warning: most of you won't
be able to read it. I'm using J, and J is very terse and
it uses a lot of punctuation, but don't worry about that.

If you don't care about J or think it looks like a cat
walked over my keyboard, that's okay. I'm not going to
stop and explain the notation in this video, but I will
explain what it's doing.

What I really want to get across in this video is just
the flow of ideas - how to think with the building
blocks J gives us.

If this inspires you to implement something in your own
favorite language, I'd love to hear about it. Send me
a link in the comments!

But if you are learning J, or you're just convinced the
code I'm showing is an elaborate joke and want me to prove
it isn't, I am going to post a separate code review video
where I walk through each line.

So if you want to see that, or you just want to see more
videos like this, now's a great time to hit the subscribe button.

Meanwhile, on with the show.

** DONE inheritance
#+begin_src j
cocurrent 'sandpiles'
coinsert 'gridpad'

cocurrent 'sandpaint'
coinsert 'sandpiles'

cocurrent 'sandcalc'
coinsert 'sandpiles'
#+end_src

This set up an inheritance hierarchy.

Normally these lines would be scattered across different files,
but I'm executing code directly off the slides so I'm just setting
things up from the start.

The word cocurrent switches the current locale, which is J's
term for a namespace, creating it if it doesn't already exist.

Then coinsert modifes the lookup path for names in a current locale.
It's kind of a freeform inheritance mechanism, and here I'm inheriting
entire applications and just overriding the parts I want to change.

So we'll put all the colors and the simulation logic into
this sandpiles application.

And these other two applications are going
to override and modify that in different ways.

** setup for next slide                                        :stage:
#+begin_src j
NB. hide terminal, run next window, bring to lower left quadrant.

#+end_src
** DONE sandpiles window
#+begin_src j
cocurrent'sandpiles'

gpo_title =: 'sandpiles'
gpo_colorpick =: 0
gpo_palv_wh =: 50 480

gpw_init''
#+end_src

So we'll start by overriding the title,
turn off the ability to pick new colors,
and make the palette view a bit wider
so there's room to draw some labels.

Then =gpw_init= fires up our modified gridpad.

** DONE sandpile colors
#+begin_src j
cocurrent 'sandpiles'

pal =: 0 1 2 3, 2^2+i.16                        NB. the actual values to draw
pen =: 1

lo =: 16b00000f 16b3f3f9d 16b7878d8 16bacacff   NB. i.4 drawn as shades of blue
hi =: 16bff0000 + 16b001100 * i._16             NB. 4+i.204 are yellow..red
rgb =: lo,hi

NB. map any number of grains to rgb
to_rgb =: rgb {~ (<:#pal) <. pal I. ]

NB. map rgb colors back to the palette
shl =: 32 b. ~
to_pal =: pal {~ (#rgb) | rgb i. (1 shl 24)&|

#+end_src

This code sets up our colors.
: (run)
The palette isn't hooked up to the timer
so we click the window to make it repaint.

So the palette is just the raw numbers zero through four
and then 8, 16, 32, and so on.

The verb =to_rgb= maps numbers in the image
to one of those intervals.
For example, 11 falls between 8 and 16,
so we color it like an 8.

This part in the middle says that if the number is out of range, just
map it to the last entry.

Also, if you open a PNG file in here, =to_pal=
strips out the alpha channel then maps these exact colors
to those exact numbers. The part in the middle on this one
says map any other color to zero.

Again, if you want to know what all the symbols mean check
out the code review video. But for now, we have our colors,
so let's move on.

** DONE palette labels
#+begin_src j
cocurrent 'sandpiles'

gpw_palv_paint =: verb define
  gpw_palv_paint0''                              NB. call original

  NB. draw text labels over the colors:
  glfont 'consolas 8'
  glpen 1 [ glbrush glrgb 0 0 0
  gltextcolor glrgb 255 255 255
  h =. {: palv_cellsize''
  for_n. pal do. i =. n_index
    if. i < 16 do. text =. ": n else. text =. '2^',":i-2 end.
    xx =. 25 - -: ww =.(8*#text)   NB. center text horizontally
    yy =. <.h*i+0.275              NB. vertically
    glrect xx, yy, (ww+1), 14
    gltextxy (2+xx),yy
    gltext text
  end.
)
#+end_src

This is the paint event handler for the palette view.

: run and click

It calls the original handler from gridpad,
and then does an expliict loop through the palette to draw labels.

** DONE approaching the rules
#+begin_src j
cocurrent 'sandpiles'

gpw_char =: verb define  NB. key handler for imgv and palv controls.
  select. {. sysdata     NB. 'wasd' is ',aoe' on a dvorak keyboard :)
    case. '>' do. render img =: img > 3           NB. greater than 3
    case. ',' do. render img =: }. img , 0        NB. move up
    case. 'o' do. render img =: }: 0 , img        NB. move down
    case. 'a' do. render img =: }."1   img ,. 0   NB. move left
    case. 'e' do. render img =: }:"1 ] 0 ,. img   NB. move right
  end.
)
#+end_src

And now we get to the fun stuff.

So this is the keyboard handler. I'm using it to define
some keyboard shortcuts to help you visualize the steps
of the sandpile simulation.

Let's say we have some arbitrary sandpile

: open face.png

... and we need to decide what's going to happen next in our simulation.

The rule is that any cell with 3 grains or fewer is stable,
so we only care about values greater than 3. So in this image,
all we want are the eyes and mouth and these little antennas
on top, and this border.

To isolate those, we can just compare the whole image to the number three.
The basic comparision operators in J work on individual items, so
we wind up with a rank 2 array of zeros and ones.

So now this image represents one grain of sand for each cell that's going to topple.
We just need to make a copy of this array shifted over one cell in each of the four directions.

That's what these other four lines do.

# show it

So a rank two array is basically a list of rows.
So to shift the image up, we add a row of zeros at the bottom and then chop off the first row.

To shift down, we add a row of zeros to the start and cut off the bottom row.

Left and right work the same way, but they operate at the row level, or rank 1.

We lost some sand along the way here because it fell off the edge. We need to
make a fresh copy before we nudge in each direction so we don't lose it.

But then all way have to do is take our four shifted copies and add them to the
original image, and then subtract four to remove them from the center.

** DONE settle
#+begin_src j
cocurrent 'sandpiles'

settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (filling in with 0 rather than wrapping)
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)

update =: verb define
  img =: settle img
)
#+end_src

So here's what that looks like.

It's exactly what we just said, where y is the original image,
gt is the fresh copy we start with each time,
and we shift it up down left and right.
Then cn just multiplies it negative four.

Then result is all of that added back to the original image.

Then this update method is gridpad's hook to perform our animation,
so once I run this,
I can draw with sand and it topples in real time.

Okay, so that's the beginner way to write this in J.

If you're disappointed that this is too readable and easy to understand
and you were hoping for something more exotic to impress your friends
and terrify your enemies then I have just the thing for you.

* DONE 1a. code golf
#+begin_src j
NB. (title card: code golf)
#+end_src
** DONE golfed sandpile sim
#+begin_src j
load'viewmat'

f=:_1 1|.!.0"0 _]
s=:(++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

viewmat s 50 50$4
#+end_src

Here is a complete standalone J program
that fills a 50 by 50 grid with the number four,
runs the sandpile simulation until it stops,
and outputs the results.

** DONE golfed sandpile sim (with color)
#+begin_src j
load'viewmat'

f=:_1 1|.!.0"0 _]
s=:(++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

NB. was:     viewmat s 50 50$4
'rgb' viewmat to_rgb s 50 50$4
#+end_src

If you want our color scheme you can borrow =to_rgb=.

# run it

Btw, the title here says "golfed"...
Code golf is a game programmers play where you try to
express an idea in as few characters as possible, and
J is a favorite language among code golfers.

Actually, this is the shortest version of the sandpile
simulation I could think of, but it's also pretty much
the natural way to write it in J - at least for me.

The only thing I did to golf it was to remove
all the extra spaces.

Now if you have any interest at all in J, I encourage
you to download J and try this for yourself, and then
see if you can figure out how it works.

If you're realy brave, maybe you can come up with an
even shorter way to write it.

And again, I'll explain the entire line character by
character in the code review.

Meanwhile, back to our program.

* DONE 2. sandpaint
#+begin_src j
NB. (title card: sandpaint)
#+end_src
** DONE sandpaint window
#+begin_src j
cocurrent 'sandpaint'

img =: 32 32 $ 0

gpo_title =: 'sandpaint'
gpo_timer =: 500
gpo_palv_wh =: 50 800
gpo_imgv_wh =: 800 800
gpo_gridrgb =: 0 0 0

gpw_init''

NB. move it on-camera:
wd 'pmove 900 100 0 0'
#+end_src

So here's the main code for sandpaint.
It just sets the window title and timer speed,
changes the size of the controls.

** DONE time control
#+begin_src j
cocurrent 'sandpaint'

gpw_char =: verb define
  time_keys''
)

time_keys =: verb define
  select. {. sysdata
    case. ' ' do. gpw_timer [ wd'ptimer 0'          NB. space = single step
    case. '1' do. wd'ptimer 1000'                   NB. 1 = pretty slow
    case. '2' do. wd'ptimer 500'                    NB. ...
    case. '3' do. wd'ptimer 100'
    case. '4' do. wd'ptimer 50'
    case. '5' do. wd'ptimer 25'                     NB. ...
    case. '9' do. wd'ptimer 1'                      NB. 9 = fast as possible
    case. '0' do. wd'ptimer 0'                      NB. 0 = stop
  end.
)
#+end_src

Here's a first pass at the keyboard handler.

The event handler name is windowname underscore timer so
setting ptimer 0 and then calling =gpw_timer= lets us fake
a timer event every time we press space.

The rest of these just run the clock at various speeds from
once a second when you press one, all the way up to once a
millisecond (or really just as fast as it can go)
when you press 9, and then zero stops it completely.

That's almost it for sandpaint. All that's left is to add a
few more shortcuts when we look at the original sandpile
paper. So let's do some science.

* DONE 3. sandpaper
#+begin_src j

NB. (title card: sandpaper)

cocurrent 'sandpaint'
wd'psel ',(":gpw_hwnd),'; ptimer 0'
pen =: 4
#+end_src
** DONE intro text (talking head cam)

There have been a number of papers written about
the mathematical properties of sandpiles,
but it was actually a physics paper that introduced
them to the world.

# show the paper
The paper was _Self Organized Criticality: An Explanation of 1/f Noise_,
by Per Bak, Chao Tang, and Kurt Wiesenfeld, and it  appeared
in the July 1987 issue of Physical Review Letters.

# show scholarpedia charts
So 1/f noise (or pink noise) is the name for a phenomenon
that crops up in all sorts of seemingly unrelated fields,
from the level of rivers, to heart rates,
to fluctuations in electrical components.

1/f noise was first identified in vaccuum tubes in 1925.
But, it was Benoit Mandelbrot who pointed out how widespread
it was in nature, and his book, _The Fractal Geometry of Nature_,
which was published five years before the sandpile paper,
seems to have helped popularize the concept.

This best explanation I could find for what makes
1/f noise interesting actually comes from Mandelbrot
by way of Martin Gardner:

#+begin_quote text
These deep notions [of spectral density and
autocorrelation]... are technical and hard
to understand.

[... Mandelbrot] has suggested a way of avoiding them here:

Let the tape of a sound be played faster or slower
than normal. One expects the character of the sound
to change considerably. A violin, for example,
no longer sounds like a violin. There is a
special class of sounds, however, that behave
quite differently. If you play a recording of
such a sound at a different speed, you only have
to adjust the volume to make it sound exactly
as before. Mandelbrot calls such sounds
"scaling noises".
#+end_quote

# show white/pink/brown chart
Gardner goes on to give three examples of such scaling noises:
white noise, where each value is completely random,
brown noise, where the value simply moves up or down at each tick,
and pink noise, is somewhere in between.

In particular, the spectral density of the noise is what
you'd see on your stereo's graphic equalizer if you tried
playing these patterns as sound waves.

Well, assuming your graphic equalizer made log-log plots.
Otherwise they look like this:

#+begin_src j
load'plot'
'keypos top right;key 1/f^0 1/f^1 1/f^2' plot % (0 1 2) ^~/ 1+i.10
#+end_src

If you look at these exponents, it's clear that in some sense,
1/f noise is halfway between white and brown noise.

The mystery is why would this somewhat random but self-similiar
scaling pattern crop up in so many places in nature?
What sort of physical mechanism would cause that?

And that's where sandpiles come in.

Now, I'm not going to pretend to fully understand this paper.
To be honest, I don't have a terribly advanced background in
math and science, and it was a difficult read for me, so
I can't guarantee that everything I say here is accurate,
but I'll do my best.

** DONE the sandpaper experiment
#+begin_src j
cocurrent 'sandpaint'

copy =: img

gpw_char =: verb define
  time_keys''
  NB. "Self-organized criticality: an explanation of 1/f noise"
  NB. Per Bak, Chao Tang, and Kurt Wiesenfeld
  select. {. sysdata
    case. 'u' do. render img =: 1 1 $ 0            NB. unit sandpile
    case. '7' do. render img =: 1 1 $ 7 + 4*20     NB. four score and 7
    case. '@' do. render img =: 32 32 $ 2          NB. @ = all 2
    case. '#' do. render img =: 32 32 $ 3          NB. # = all 3
    case. '$' do. render img =: 63 63 $ 4          NB. $ = all 4
    case. 'r' do. render img =: ? 32 32 $ 4        NB. r = random grid
    case. 'R' do. render img =: 4 + ? 100 100 $ 4  NB. R = big random grid
    case. 'f' do. render img =: settle^:_ img      NB. f = fast forward
    case. 'c' do. copy =: img                      NB. c = copy
    case. 'x' do. render 'img copy' =: copy;img    NB. x = swap
    case. '?' do. viewmat copy ~: img              NB. ? = show diff
  end.
)
#+end_src

The first part of the paper is an argument about connected systems in general. They give the example of how forces propagate through an array of pendula connected by springs. But the one dimensional case isn't
terribly interesting - the energy just moves down the line.

I made a couple attempts to illustrate the point they were making
with a 2d array of pendula, but I didn't really have the right set of dimensions to work with in a 2d physics program, and even when I
replaced the pendula balls on springs and turned off gravity it's just really hard to tell what's going on in a physics simulation.

Their point isn't tied to any particular system, though, and they
introduce sandpiles as an abstract model that's easy to simulate.

So let me attempt to make their point, as I understand it,
using the sandpile simulation.

The first concept is a minimally stable state.
Suppose you have the unit sandpile. ('u')
This is a 1x1 array with a single cell.

We can put any value we  like in here, but there's only four values that make it stable. Of course all the unstable values in our palette are multiples of four, so if we put any of those in there, it's going to wind down to zero.

But if we put a number like 87 in there, it settles down to 3.
Three is the minimally stable state for a sandpile in the sense that
you can be more stable, but you can't be less stable without actually toppling.

When we look at the system as a whole, especially a real system out in nature, we would be very surprised to find all the units in a minimally stable state.

Why not?

# show "all 3" configuration

Why? Well, the slightest disturbance at the edge sends a cascade of changes out through the system, and every single cell gets affected. Since nature is messy and complicated, we'd expect lots of small disturbances to happen, and so a uniform minimally stable state probably wouldn't last very long.

But as we encounter more and more disturbances, these areas of more stable cells start to build up, and they stop the noise from propagating. But every once in a while, a signal still gets through into one of these big areas.

And that's the key idea. As they write in the paper:

#+begin_src quote
The system will become stable precisely at the point when the network of minimally stable states has been broken down to the level where the noise signal cannot be communicated through infinite distances. At this point there will be no length scale in the problem so that one might expect the formation of a scale-invariant structure of minimally stable states.
#+end_src

In other words, since nothing we've discussed depends on the size of the system, there's no particular constraint on how big your connected island of threes is, so it shouldn't be a surprise that we get patches of all different sizes.

On the other hand, and this is just my interpretation, maybe the bigger patches near the outside are more likely to get hit, and therefore more likely to get broken down themselves, whereas big islands towards the center would be more protected, and so maybe something like this is what leads to the 1/f distribution of effects in nature.

Of course the argument is a lot less credible if it only works when everything starts in the minimally stable configuration, because then you have to explain why things start out that way.

# show "all 2", demonstrate that clicking does nothing.

Now if we started with all twos, it's already incredibly stable. You can nudge it all you want and it barely makes a dent.

And if we start with a stable configuration at random, it's also likely to remain stable. In a purely random configuration, there's no particular incentive for large areas of threes to form.

# press 0 $

The trick is to start with an unstable system. For example, here's a 63 by 63 grid of fours. (And by the way this is going to start strobing a bit so if you're sensitive to flashing lights you might want to look away for a moment.)

# press 9 and wait

Okay it's done... And you can see already that there are a bunch of different sizes of islands all around the edge.

So this is an example of what the authors call a critical state. It's stable, but large portions are only minimally stable. And the hypothesis put forth in the paper is that an interconnected system that starts out completely unstable will naturally wind down into one of these critical states, rather than one of the more stable configurations we saw earlier. Hence the phrase "self-organizing criticality."

So the next step was to test this hypothesis, and they did that on the computer, using the sandpile simulation.

Basically, they started with a big random grid of numbers slightly greater than three.

# press R

This takes forever to animate, and it's not especially interesting to look at, so let's fast forward.

So hopefully this is a sandpile in a critical state, but with everything so mixed up, it's not obvious how to tell.

It does look different from the random piles we saw before.

I press 'c' to copy this for a second, and then press 'r' to see a random stable grid. 'x' swaps back and forth.

Notice that almost all the black squares are isolated by themselves, and there seem to be way more twos and threes overall.

In fact, lets can look at it numerically.

: 'bar' plot >([: +/@|: (i.4)=/]) each img ;&, copy

So actually way more threes. Here are the counts from when we started with all fours for comparison.

: 'bar' plot 481 136 764 2588,~ >([: +/@|: (i.4)=/]) each img ;&, copy

Maybe there's something worth exploring in measurements like these, but getting back to the paper, the experiment went something like this.

- Generate a big unstable grid
- let it settle
- take a snapshot so we know the original state
- then set any one of the cells to four and let it play out.
- then compare the before and after images, record the size of the change

: +/+/ copy ~: img

Then they did this a bunch of times and recorded the results.

Now they're a little unclear on the details here. Did they keep hitting the same spot every time, and observe a progression, or was it different spots? And if it was different spots, did they reset the array each time?

Also notice there's some dark areas inside the perimiter, where cells might have been affected during the run but then settled back to their original values. They did include a graphic which shows them filled in, which makes me think they count.

So anyway, let's reproduce their experiment as best we can and see what happens.

Of course, rather than do that by hand, we'll let J do the work for us.

** DONE the experiment
#+begin_src j
Note 'sandpaper setup'
  - full screen term window
  - 'desktop only' in obs
  - session font to consolas/24
)
open'~JTalks/s1/e2-sandpiles/sandpaper.ijs'
#+end_src

: work through the code there
: (splice in the animplot stuff)

: show final result vs their log-log plot.

So here's their results. Note that their graph only goes up to 1000,
so they're only looking at the central part anyway. They say this part
of the graph keeps smoothing out as you make the arrays bigger and bigger.

Even looking only at the middle,
I don't really understand what they did to get
a graph that smooth and close to the line.

Certainly my own plotting skills need some work,
especially in J, but it does look like the general
idea checks out.

Not only do unstable sandpiles settle down into critical
states that give rise to lots of different reaction sizes,
but those sizes tend to follow something close to a 1/f
distribution.

By the way, the bottom chart is for running the same
kind of simulation in 3 dimensions. Presumably they
used cubes and distribute changes to six neighbors
instead of four. Maybe someone out there can make a
3d version in minecraft. If so, I'd love to see it. :)

Also, these charts on the right plot the distribution of
reaction lengths - as in the number of steps the reaction
took before settling down.

So they are addressing a 1/f distribution in time dimension,
although it's still not clear to me how any of this maps
to one over f noise in a frequency spectrum.

Anyway, that's my take on the sandpaper. Like I said before,
it was kind of a stretch for me to get my head around all
that, so if I got anything wrong or just wasn't clear,
then by all means, please set me straight in the comments.

Meanwhile, let's shift gears from science to math,
and take a look at sandpile addition.

* DONE 4. sandcalc
#+begin_src j

NB. (title card: sandcalc)

#+end_src
** DONE sandcalc
#+begin_src j
cocurrent 'sandcalc'
coinsert 'sandpiles gridpad'

gpo_title =: 'sandcalc - sandpile calculator'
gpo_timer =: 200
gpo_statusbar =: 0
gpo_colorpick =: 0
gpo_menu =: ''

gpw_init_controls =: verb define
  wd'bin h'
  wd' minwh  50 200; cc palv isigraph;'
  wd' minwh 200 200; cc sp0v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp1v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp2v isidraw;'
  wd' cc "=" static;'
  wd' minwh 200 200; cc sp3v isidraw;'
  wd'bin z'
)

render =: ]  NB. because there's no 'imgv' control

gpw_init''

#+end_src

Okay so here's a new window with four little sandpiles.

** DONE sandcalc - render
#+begin_src j
cocurrent 'sandcalc'

pal =: i.4                      NB. limit to stable piles
pen =: 0                        NB. color to draw with

NxN =: 5 5
sp0 =: NxN $ 0
sp1 =: NxN $ 3
sp2 =: NxN $ 0

(update =: verb define)''
  sp3 =: settle^:_ sp0 + sp1 + sp2
)

render =: verb define
  vmcc sp0;'sp0v'
  vmcc sp1;'sp1v'
  vmcc sp2;'sp2v'
  vmcc sp3;'sp3v'
)

#+end_src

The animation here is just like before except we're going to
limit the palette to our four stable values, and on every
tick we're going to add the first three sandpiles together
let it settle, and show the result on the right.

** DONE sandcalc - mouse
#+begin_src j
cocurrent 'sandcalc'

gpw_sp0v_mwheel =: gpw_sp1v_mwheel=: gpw_sp2v_mwheel=: gpw_palv_mwheel

NB. left click draws on the input
gpw_sp0v_mblup =: verb : 'sp0 =: sp0 img_draw whichbox 40'
gpw_sp1v_mblup =: verb : 'sp1 =: sp1 img_draw whichbox 40'
gpw_sp2v_mblup =: verb : 'sp2 =: sp2 img_draw whichbox 40'

NB. left drag does the same
gpw_sp0v_mmove =: verb : 'if. mbl _ do. gpw_sp0v_mblup _ end.'
gpw_sp1v_mmove =: verb : 'if. mbl _ do. gpw_sp1v_mblup _ end.'
gpw_sp2v_mmove =: verb : 'if. mbl _ do. gpw_sp2v_mblup _ end.'

NB. right click to copy the sum to an input
gpw_sp0v_mbrup =: verb : 'sp0 =: sp3'
gpw_sp1v_mbrup =: verb : 'sp1 =: sp3'
gpw_sp2v_mbrup =: verb : 'sp2 =: sp3'

NB. middle click to reset the input
gpw_sp0v_mbmup =: verb : 'sp0 =: NxN$0'
gpw_sp1v_mbmup =: verb : 'sp1 =: NxN$3'
gpw_sp2v_mbmup =: verb : 'sp2 =: ZSP'

ZSP =: NxN $ 0 NB. the trivial zero
#+end_src

We can draw in each of the first three just like
before.

Right clicking one of the inputs causes it to copy
the sum over, and middle clicking resets the input.

So for example,

: set middle to single square, leave others at 0

one plus one is two

right click to copy the two

one plus two is three

copy the three

one plus three is four

and of course the pile of four topples over.

One more time...

And that's how the plus sign was invented. :)

Once again, I'll explain all this code in the code review, but I do want to point out these last few lines.

The middle click handler on sp0 (this left one) sets it to an array of all zeros.
Then sp1 is all threes, and sp2 is ZSP, which stands for zero sandpile.
And on the next line I've temporarily defined it as all zeros.

The reason I made a variable for this one
is that it's just a placeholder.

It turns out that when you add sandpiles
together, there's always at least one other
sandpile that acts like a zero.

Let's take a look.

** DONE the zero sandpile
#+begin_src j
cocurrent 'sandpaint'

gpo_showgrid =: 1
gpo_gridrgb =: 3 $ 255

wd'psel ',(":gpw_hwnd)
wd'pmove 970 100 0 0; ptop; ptimer 0'

render img =: ((0,0,~])&.|:)@(0,0,~])^:8 ]  5 5 $ 4

#+end_src

So there's actually an algorithm for finding the zero.

You start with an array of fours in the shape you want.

So here it's a five by five array of fours.
(This part just adds an a border of eight zeros around it.)

Then step through until it settles.

We can ignore the sand that fell off.

And now we're going to subtract each of these values from four.

The zeros become fours.

If we had any ones, we'd turn them into threes, but we don't.
And the twos stay the same.

And the threes turn into ones because four minus three is one.

Settle this one more time, and whatever's left is your zero.

...

Now before we try it out, let's set our expectations.

There's no way we could ever start from this zero and get
back to our simple plus sign, or even to the array of all zeros.

We can set any particular square to zero by figuring out what
you need to add to it to make four and letting it topple, but
every time you send a grain of sand off the edge, you're also
sending at least two grains back inward.

In fact if you think back to our random settled sandpile,
remember we noticed that all the zeros were isolated?

The evidence seems to suggest that it's just
plain impossible to get two empty squares next
to each other by adding sand. You have to create
them directly.

It seems like it ought to be possible to
prove that statement, and there are a bunch of math
papers about sandpiles, so maybe it's already been done,
but let's just call it a conjecture.

The point is there's nothing we're ever going to
add to this zero sandpile that's going to give us back
a completely empty sandpile.

So this new zero only works for some numbers. But
let's see what happens when we add it to our minimally
stable configuration.

: (draw it by hand)

And there we go. All threes plus this zero is all threes.

** DONE the zero sandpile in j

#+begin_src j
cocurrent 'sandcalc'

stl =: settle^:_
ZSP =: stl (4 - stl) NxN $ 4

#+end_src

Okay so before we get too carried away, here's a restatement
of the algorithm to construct this thing in J.

Now we can draw whatever we want in the third slot
and middle click to bring back the ZSP.

And if we set the other two sandpiles to all zeros,
it's obvious that adding these three together should
gives us ZSP. But also if we add three copies of ZSP
together, we get ZSP.

And by the way, that's not a commonly accepted name or anything.
It's just what I called it.

I actually first learned about Sandpiles from a Numberphile video.
I first heard about them on a numberphile video (which I've linked
in the description) Dr. Luis David Garcia-Puente does a pretty
deep dive into the math of these zeros.

According to him, the set of sandpiles for which this zero works
is precisely the set you get by adding something to the array of
all threes. So that's why I put all threes in the middle.

So it turns out that if you take the set of sandpiles you get
from adding anything to the array of all threes, that set forms
a group. I don't know if it has a name, but given the original
paper, I'm just going to call it the critical group.

** DONE sandpiles under addition form an abelian group
#+begin_src j
cocurrent 'sandcalc'

O =: stl @: +

Note 'Definition of Group G with operation O'

 NB. Closure
 (*./(a,b) e. G) <: ((a O b) e. G)

 NB. Associativity
 (*./(a,b,c) e. G) <: ((a O b) O c) -: a O b O c

 NB. Identity element (e) (ZSP in our case)
 (a e. G) <: ((e O a) -: (a O e)) *. (a -: a O e)

 NB. Inverse elements  (I)
 (a e. G) <: (a O I a) -: e

)

Note 'Abelian Group'

  NB. Commutativity
  (*./(a,b) e. G) <: (a O b) -: (b O a)

)

#+end_src

When I say group, I mean a group in the mathematical sense,
which just means it follows these rules.

- the sum of two group members is a member
- it doesn't matter which order you add things in
- there's some identity element
- and for every element, there's an inverse element you can add to it to get the identity.

As it happens, it's also an Abelian group, so a plus b = b + a.

By the way, this is actual J syntax. If we collected all the critical sandpiles into rank 3 array called G and we had a definition for this inverse function, then we could turn this into a verb and actually run it as a test case.

Now building G might take a lot of RAM, but it's just enumerating every possible sandpile and adding all threes to it.

What about the inverse function?

Well, I was going to say I had no idea,
but pretty much the first algorithm I tried work.

** DONE finding an inverse
#+begin_src j
cocurrent 'sandcalc'

gpw_sp0v_char =: gpw_sp1v_char =:gpw_sp2v_char =: verb define
  select. {. sysdata
    case. 'i' do. render sp0 =: e - sp1     NB. left = "inverse" of middle
    case. 'a' do. render sp0 =: e O sp0     NB. add ZSP to left
    case. 'p' do. echo <sp0                 NB. print sp0
  end.
)
#+end_src

: demo with arbitrary sandpile in the middle

Except of course it doesn't actually work
because this is showing all zeros and
we know this should add up to three.

Of course it's just a display bug.
We have negative numbers in the grid
and that's not supposed to happen so
the coloring function doesn't account for it.

But it turns out if we just keep adding the zero
sandpile until the holes fill up, this approach
actually does work after all.

Again, I don't have a formal proof of that
statement, but as far as I can tell,
it always works.


** DONE actual inverse
#+begin_src j
cocurrent 'sandcalc'

I =: [: e&O^:_ e - ]

gpw_sp0v_char =: gpw_sp1v_char =:gpw_sp2v_char =: verb define
  select. {. sysdata
    case. 'i' do. render sp0 =: I sp1          NB. left = inverse of middle
    case. 'a' do. render sp0 =: e O sp0        NB. add ZSP to left
    case. 'p' do. render sp1 =: 3 O ? NxN $ 4  NB. middle = random puzzle
  end.
)
#+end_src

So even though it's easy to generate the inverse with a program, it's not easy to guess what it's going to look like, even if you know the algorithm.



It's actually kind of an interesting puzzle to find a group item and then try to figure out the inverse.

And so I'll leave you with what may be the most important equation of sandpile addition.

All threes.

All threes.

All threes.

And that, boys and girls, is where the plus sign really comes from.

* DONE _. outro

Thank you so much you for watching my video.

I hope you enjoyed it as much as I enjoyed making it.

If you did, and you'd like to encourage me to make more of these, I'd really really appreciate it you shared the link with someone else who might like it.

And for the last time, if you want to know what all those squiggly marks were about subscribe to this channel and click the little bell icon to get notified when the code review comes out.

If you don't care about the code but liked this kind of video, let me know in the comments. The next one I'm planning is on the Mandelbrot set, and whether or not I split it into a general presentation and a code review is probably going to depend on what people think of this video.

Anyway, thanks again for watching, and I hope to see you again.


* DONE Video Description and Links

Code for this episode:
https://github.com/tangentstorm/j-talks/tree/master/s1/e2-sandpiles

Numberphile video on sandpiles with Dr Luis David Garcia-Puente:
https://www.youtube.com/watch?v=1MtEUErz7Gg

(The note about adding all 3's is at the 8:00 mark.)


Professor David Perkinson has a textbook on sandpile math, as well as interactive software:
http://people.reed.edu/~davidp/

Original sandpile paper:
http://cqb.pku.edu.cn/tanglab/pdf/1987-63.pdf

Sandpile math paper, including the algorithm to generate the "zero":
https://hal.archives-ouvertes.fr/hal-00016378

WikiZero on sandpiles:
https://www.wikizero.com/en/Sandpile

Code golf challenge with sandpiles in various languages:
https://codegolf.stackexchange.com/questions/92251/build-a-sandpile

J Vocabulary:
https://code.jsoftware.com/wiki/NuVoc

Download J from:
https://code.jsoftware.com/wiki/Guides/Getting_Started


* TODO credits (if I use these images)

Earthquake chart by Gavin Hayes
https://web.archive.org/web/20190530181052/https://earthquake.usgs.gov/learn/topics/mag-intensity/


Mandelbrot photo by Steve Jurvetson - https://www.flickr.com/photos/jurvetson/4770047266/


Martin Gardner photo by Konrad Jacobs
https://opc.mfo.de/detail?photo_id=1292
