#+title: sandpiles in j

* TODO :recap
#+begin_src j
NB. run sandpaint
#+end_src


- quick recap: what are sandpiles?
- this is the code review for the sandpiles video
- covered most of the gui logic in the basic animation and sprite editor videos
- will focus on these two screens

sandpiles are a fun little cellular automata that can make some interesting patterns.

I did a whole video on them a while back, but since I thought it might be interesting to a wider audience than my usual J programming videos, I decided to cover the actual implementation in a separate video. That's what you're watching now.


- sandpiles are just rank 2 arrays (formally they can be any graph, but rank 2 array is how I presented them)
- viewmat to render at each frame
  - viewmat comes with j
  - but we need color
- most of the video on the step function
- instead i want to focus on the rule, and how to get to the short version
- help you understand both versions and how one is derived from the other
- talk a little bit about rendering real quick

* :colormap

We can render pretty much any matrix with viewmat:

** :viewmat-repl-demo                                          :repl:
*** :normal-viewmat
#+begin_src j
i. 2 2   NB. a stable sandpile
load viewmat
viewmat i. 2 2
#+end_src

*** :console-viewmat
#+begin_src j
install 'github:tangentstorm/j-kvm@main'
load 'tangentstorm/j-kvm/vm'
vm i. 2 2
#+end_src

*** :viewmat-colorspace
#+begin_src j
NB. rgb hex codes for some shades of blue
p0 =. 16b00000f 16b3f3f9d 16b7878d8 16bacacff
p0 vm i. 2 2

p1 =. 16b0f0000 16b9d3f3f 16bd87878 16bffacac
p1 vm i. 2 2

p2 =. ((3#256)#:p0)
p2 vm i. 2 2
#+end_src
We can pass in a custom palette to control the colors.
Most programs tend to use 'rgb' ordering.
Viewmat uses 'bgr' ordering.
So you can either write them backwards, or you can send a rank two array in rgb order.

*** :viewmat-interpolation
#+begin_src j
p2 vm i. 10 10
#+end_src
But if we try use more numbers, then it interpolates.

*** :viewmat-minmax
#+begin_src j
 2|i. 10 10
p2 vm 2|i. 10 10
#+end_src
It also only looks at the biggest and smallest numbers in your array,
so here it shows all the ones using the color we want for four.

*** :viewmat-rgb
#+begin_src j
'rgb' vm p0{~ 2|i. 10 10
'rgb' vm p0{~ 4|i. 10 10
'rgb' vm p0{~ i. 10 10  NB. more numbers than are in the palette
3 { p0
5 { p0   NB. index error
#+end_src
this works great when the values are 0, 1, 2, or 3, but
but if we use a number outside the range, we'll get an index error.

*** :rgb-gradient
#+begin_src j
'rgb' vm 16b001100
'rgb' vm 16b001100 * i.16
hfd 16b001100 * i.16
'rgb' vm 16bff0000 + 16b001100 * i.16
'rgb' vm 16bff0000 + 16b001100 * i._16
#+end_src
so we can fix this by making our own gradient.
that's almost too dark to see.
but we can multiply that by a range to go from black all the way to pure green.

So that's like multiplying by eleven hundred in decimal...
it gives us the digits, 00,11,22 all the way up to ff.

anyway, adding pure red to that gives us a gradient from red to yellow.
I actually wanted yellow to red, so we can just make the 16 negative.

*** :rgb-palette
#+begin_src j
'rgb' vm p0, 16bff0000 + 16b001100 * i._16
p0
lo =. 16b00000f 16b3f3f9d 16b7878d8 16bacacff   NB. black and blue/indigo
hi =. 16bff0000 + 16b001100 * i._16             NB. 4+i.204 are yellow..red
'rgb' vm pal =. lo,hi
pal =: lo,hi
#+end_src
so if we add p0 back in, we have our palette.

now we have to map all the numbers greater than four to this range.

I wanted pure yellow to mean 4,
then this next color to mean 5 through 8,
and then 9 through 16,
then 17 through 32,
using powers of two each time.

*** :interval-index
#+begin_src j
NB. map any non-negative integer to the palette
idx =: 0 1 2 3, 2^2+i.16
idx I. 0 1 2 3 4
idx I. 0 1 2 3 4 5 6 7 8
idx I. 0 1 2 3 4 5 6 7 8 9 10
#+end_src
so the idea is to make in index of the palette.
then we can use Interval Index (dyadic cap I dot) to map any number to that range.
the left argument is a list of ascending numbers.
then for each item on the right, it figures out where it would have to go in the left argument to keep that list sorted.

so here anything 0 or less goes in bin 0.
1 goes in bin 1.
2 goes in bin 2.
and so on up to 4.
then 5 6 7 and 8 all go into bin 5,
9 goes into bin 6
and so on.

*** :indexed-palette
#+begin_src j
pal {~ idx I. 0 1 2 3 4 5 6 7 8 9 10
'rgb' vm pal {~ idx I. 0 1 2 3 4 5 6 7 8 9 10
vm i. 32 32
vm idx I. i. 32 32
0'rgb' vm pal {~ idx I. 2^10
'rgb' vm pal {~ idx I. 2^17
'rgb' vm pal {~ idx I. 2^18 NB. too big
idx =: 0 1 2 3, 2^2+i.15
'rgb' vm pal {~ idx I. 2^203948 NB. no problem
#+end_src
now we can use that as an index into the palette.
but of course if the numbers are too big, we're outside the palette.

in the original code I did some manual bounds checking but
what i should have done is just made the index one item shorter.
then anything bigger than 2^17 (remember we're adding 2)
goes into the last bin.

*** :smooth-color
#+begin_src j
'rgb' vm pal {~ idx I. i. 32 32
#+end_src
anyway, now we can draw sandpiles and get with this nice smooth ramping effect for the colors.

*** TODO :vsp
*** :vm-vs-viewmat
#+begin_src j
'rgb' viewmat 16b001100  NB. shape error
'rgb' viewmat ,.16b001100  NB. fix with 'ravel items'
'rgb' viewmat ,.16b001100  * i. 16
'rgb' viewmat |:,.16b001100  * i. 16
#+end_src
one last note before we move on:
all this time i've been showing individual scalars and lists with this vm verb.
If you're using viewmat in general, it'll give you an error if you try that.
but you can fix that with comma dot. It brings any array to rank 2, by turning each of the array's items into a flat list.
then for rank 1 arrays, i tend to like seeing them as horizonal instead of vertical, so if you want that, you can use transpose. (for rank 1, you could also use ,: which takes an array and wraps it in another array one rank higher. so that gives you a single row for i.10)
anyway, the 'vm' verb is doing that behind the scenes.

* TODO :animation
#+begin_src j
NB. TODO: whatever
#+end_src

- animation (i'll probably do another video on the gui stuff in the future)
i covered most of animation stuff in my other video
this time around i'm not doing anything interactive,
so i can use a much simpler technique...
or we can just skip the animations altogether.

- reusing viewmat window for animation i've talked about before
- here i'm just doing a simple loop

* :settle
** settle: step by step                                        :repl:
*** :plus-sign

Okay so now let's see how to actually do the sandpile logic.

:    n?0 0 4 0 0?       !
:  b n?0 0 4 0 0? v?,:? !
: 2b n?4 4 4 4 4? v?,?  !
: 2b n?0 0 4 0 0? v?,?  !
: 2b n?0 0 4 0 0? v?,?  !
: 2b i?y? c?=.?         !
#+begin_src j
[ y  =. 0 0 4 0 0, 0 0 4 0 0, 4 4 4 4 4, 0 0 4 0 0,: 0 0 4 0 0
#+end_src

Here's a little 5x5 grid with a plus sign made of fours.

*** :gt
Where is y greater than 3?

#+begin_src j
y > 3
#+end_src

All the fours turn into ones.

let's call that gt.
#+begin_src j
gt =. y > 3
#+end_src

notice it didnt print out the grid this time. j hides the result when the leftmost part of the line is an assignment

if we put a bracket here it's just an identity function, but it changes the leftmost part of the line and so j prints the result
#+begin_src j
[ gt =. y > 3
#+end_src

The rule is that any time a cell has more than 3 grains of sand, we shift one grain in each of the 4 cardinal directions.

*** :shift-up
#+begin_src j
vsp up =. }.   gt ,  0
up
#+end_src

so to shift upward, we can append a row of 0s and chop off the top row.

to shift down, we append the 0 at the top and then chop off the bottom row.

*** :shift-down
#+begin_src j
vsp dn =. }:    0 ,  gt
#+end_src

*** :left
left and right work the same way, but we apply the rule at each row instead of to the whole array

so for left we use this rank 1 modifier. we could do the same for the comma but it's so common that j gives us ,. (stitch)
#+begin_src j
vsp lf =. }."1 gt ,. 0
#+end_src

it doesn't necessarily mean rank 1, it means 1 less than the highest rank. but since a grid is a rank 2 array, that's rank 1.

*** :right
same idea for shifting right, but since the 0 is now right next to the 1, we have to separate them, or they'll be treated as a single token and passed to the rank conjunction. we could put parens in here somewhere, but the identity function works just as well.
#+begin_src j
vsp rt =. }:"1 ]0 ,. gt
#+end_src

*** :adding-up
Now we just want to add all these together.
#+begin_src j
vsp y + up + dn + lf + rt
#+end_src

And of course remove four from the centers:
#+begin_src j
[ cn =. _4 * gt
vsp y + up + dn + lf + rt + cn
#+end_src

** settle monad
#+begin_src j
settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (fill in with 0 rather than wrap)
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)
#+end_src

** the short version
#+begin_src j
f =: _1 1 |.!.0"0 _ ]
s =: (+ +/@(_4&*,f,f&.(|:"2))@(3&<))^:_
vm s 50 50 $ 4
#+end_src

Was the most obvious way to write it at the time.
You might think this is write-only code.

This right bracket doesn't match with anything.
The syntax highlighting really helps, but you just have to know that |: is one token whereas ++ is two
(the rule is that if it's more than one character, everything after the first character is a dot or colon)

I certainly don't just instantly grok what it says,
just like I wouldn't just instantly grok what a page of
python code means.

It's sort of like reading a long unfamiliar foreign word. You just have to take it slow and look at each piece in isolation.


** are they the same?
#+begin_src j
settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (fill in with 0 rather than wrap)
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)

f =: _1 1 |.!.0"0 _ ]           NB. golfed version
s =: (++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

NB.! before
(s -: settle) 50 50 $ 4         NB. if this=1, s and settle are same
NB.! after
(s -: settle^:_) 50 50 $ 4      NB. if this=1, s and settle are same
#+end_src
One way we can test that these are the same is to compare the outputs.
That's what this line at the bottom does.
Looks like they're not the same.
But we can change the settle to keep running until it reaches a fixedpoint.
That's what this carat-colon-underscore sequence means.
Or in the spirit of golfing, we could remove the sequence from s, and have it do only a single step.

** first golf: one step at a time
#+begin_src j
load 'viewmat'
f =: _1 1 |.!.0"0 _ ]
NB.! before
s =: (+ +/@(_4&*,f,f&.(|:"2))@(3&<))^:_
viewmat s 50 50 $ 4
NB.! after
s =: + +/@(_4&*,f,f&.(|:"2))@(3&<)
viewmat s^:_ [50 50 $ 4
#+end_src


in fact if we do that we save at least one character, because we can remove the parentheses,
and move the fixedpoint sequence down to the next line. ^:_
but we have to give a character back becaues underscore is a number (it means infinity)
and so we need an identity bracket to separate it from the 50 50.
although if you're serious about golfing, you could just replace the space.
in fact you could just remove most of the spaces, but I'd rather save that until the very end just to keep things
readable.

or you know, as readable as possible. :)

* :deconstruct
#+begin_src j
settle =: monad define
  gt =. y > 3
  up =. }.   gt ,  0
  dn =. }:    0 ,  gt
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. _4 * gt
  y + up + dn + lf + rt + cn
)

f =: _1 1 |.!.0"0 _ ]
s =: + +/@(_4&*,f,f&.(|:"2))@(3&<)
#+end_src
anyway, back to our comparison.
the bottom line of settle is a sum of a bunch of things, and most of them are derived from gt.
so if each of these were verbs that took gt as an argument, we could rewrite it like this:
: (y + up + dn + lf + rt + cn) gt
The rule is that when you have a sequence of tokens on a line or in parentheses,
then the rightmost token determines usually what your final result is going to be.
So at the moment, cn is a noun, so this whole thing in parentheses is a noun.
And then we're sticking that noun next to gt, which is also a noun, and that's a syntax error.
But if we turn cn into a verb = again we know it's a noun because we have a noun on the right,
but we can replace it with the identity function:
: cn =. _4 * ]
and now cn is a verb.
that makes this whole thing a verb train. you can have as many nouns on the left as you like,
as long as you put verbs in between them.
and by the way, that rule is a little oversimplified, because you actually can have a noun on
the right edge and still wind up with a verb, if the thing next to it is a conjunction. so
we could also write cn like this:
: cn =. *&_4
Negative four is a noun, but we're using the bind conjunction to bind it to multiplication operator so the whole thing is a verb that multiplies its argument by negative four.
anyway, now that cn is a verb, we've got a verb on the right in the parentheses, and so this whole thing
becomes a verb operating on gt.
let's turn the rest of these nouns into verbs as well.
** TODO
so now we wrap this as a verb...

the whole thing is a monad

The lines in the middle all make nouns, but they could be functions on 'gt'.

The main idea here is that a noun phrase that depends on a single variable
can be replaced with a monad applied to that variable.

We wrap the noun phrase in single quotes (escaping appropriately), put
the tokens ~monad :~ on the left, and then invoke the monad we just created
on the variable in question.

Now since we're getting the value as the first argument, we can replace
all instances of the variable with ~y~ inside the single quotes.

All five of these noun phrases can become monads acting on gt in this way.

** tacit up
#+begin_src j
up =. }. gt , 0

up =. }. ] , 0:    NB.
#+end_src
cn and the train we've created below it are what we call tacit verbs, in that they don't refer directly to their arguments.
a lot of times, tacit programming like this is going to give you a very compact representation of your operation, but it's not always obvious how to get there.
For example, with the initial rewrite of =cn=, I just replaced =gt= with the right identity bracket, and that turned it into a valid fork.
: cn =. 4 * ]
With up, we have a zero on the right, and zero is a noun, so it's not so easy. If we try doing this,
it's just going to apply a comma and right identity and the behead function to that zero. So you
enlist the zero, do nothing and then remove the first item, giving you an empty list. Not what we want!
: up =. }. ] , 0     NB. no good: empty list
So we need that zero to be a verb. You can take any primitive and turn it into a verb using the rank conjunction.
So for example, here's i.10
: i. 10
and here's i.10 zeroed out at rank zero:
: 0"0 i. 10
and at rank infinity:
: 0"_ i. 10
So for up we could say:
: up =. }. ] , 0"_   NB. still no good
or... all the single digit numbers have primitive verb equivalents if you just put a colon after them, so we could try that:
: up =. }. ] , 0:    NB. still no good
Either way, =up= is now a verb, but it doesn't do what we want because it's a hook. Basically, the verbs in a train alternate between being applied to the arguments and being applied to the results of the other verbs.
# highlight the slots
: up =. }. ] , 0:    NB. still no good
Since there isn't a verb on the left, J fills it in with a left bracket, which passes in the left argument if you use it as a dyad, and the right argument if you use it as a monad.
: 2 (,]) 3
: (,])
Anyway, that means this definition of up:
: up =.   }. ] , 0:    NB. hook. still no good
Is shorthand for this:
: up =. [ }. ] , 0:    NB. equivalent fork. still no good
Which means the right-curly dot isn't the monad called 'behead', but rather the dyad called 'drop', and that's not what we want. So to force it to be called as a monad, we'd have to cap off the left hand side of the train:
: up =. [: }. ] , 0:   NB. finally!
** tacit up (test)
#+begin_src j
settle =: monad define
  gt =. y > 3
  up =. }.   gt ,  0   NB. original
  up =. [: }. ] , 0:   NB. tacit version
  dn =. }:    0 ,  gt
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. *&_4
  (y + up + dn + lf + rt + cn) gt
)
#+end_src


Okay, so now that's actually the function we want it to be, and it will work fine in the train.

We /could/ work through that same process to turn all these other nouns into tacit verbs, but it's kind of a premature optimization and also can often do the translation for us.


So instead of tacit verbs, we can make up into an explicit verb.

Right now, settle itself is an explicit verb. The word =define= is an adverb:

: define

It's composed of a zero applied to the right side of the explicit definition conjunction (the colon).

Explicit definition takes a number on the left saying what part of speech you're defining. So here monad is just the number 3: which indicates a monadic verb.

: monad

Then the zero indicates that j is to read the definition from the following lines until it encounters a line consisting of a closing parenthesis:

: )

But instead of a zero, you can also pass in a string, and so you can use that to quickly turn any line of j into a verb:

** explicit up
#+begin_src j
up =. }. gt , 0             NB.!+v1
up =. monad : '}. gt , 0'   NB.!-v1
up =. monad : '}. y , 0'    NB.!-v2
up =. {{ }. y , 0 }}        NB.!-v3
#+end_src


So, for example, we can just wrap this whole definition in a string, stick the word monad and a colon in front of it, and we're good to go.

Of course this function ignores its argument and depends on =gt= to be defined elsewhere in the scope, but if we change the gt to the special name y, then it will perform its operations on its argument.

This is actually kind of the old way to do things. The latest cutting edge versions of J have a new syntax, which I'll show you in a minute, but I wanted to show this in case you've got an older version installed, and also because of the following trick:

We already saw that the word monad was the number 3. You can also pass in the number 0 if you want to define a noun, 1 for an adverb, 2 for a conjunction, or 4 for a dyadic verb. (All of these also have corresponding constants). But you can also pass in the number 13, and if you do that, J will make an attempt to translate your verb to tacit form:

: 13 : '}. y , 0'
: [: }. 0 ,~ ]

This version is a little different than what I did before. Instead of using the zero colon constant function, it used a tilde to swap the arguments to the comma.

The point is, for very small verbs, J can often do the tacit conversion for you.

If you're not playing code golf, there's no particular reason to always use the tacit form.
The explicit version is often clearer, and even if you are playing code golf, explicit is sometimes actually shorter.

But for this one-line syntax, sticking your code in a string is kind of unpleasant. It breaks your syntax highlighting, and it's kind of annoying when the definition itself includes a string, because you have to escape it with extra single quotes and the whole thing looks terrible.

But as of J902 beta-i, which came out in October of 2020, you can now use the direct definition syntax, which uses these double curly braces:

: only v3

** extract monads
#+begin_src j
settle1 =: monad define
NB.!if before
  gt =. y > 3
  up =. }.   gt ,  0
  dn =. }:    0 ,  gt
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
NB.!else
  up =. {{ }. y , 0 }}
  dn =. {{ }: 0 , y }}
  lf =. {{ }."1  y ,. 0 }}
  rt =. {{ }:"1 ]0 ,. y }}
NB.!end
  cn =. *&_4
  y + up + dn + lf + rt + cn
)

f =: _1 1 |.!.0"0 _ ]           NB. golfed version
s =: (++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

(s -: settle^:_) 50 50 $ 4      NB. if this=1, s and settle are same
#+end_src
** extract hook
#+begin_src j
settle =: monad define
  gt =. y > 3               NB.!+v0
  gt =. {{y > 3}}           NB.!-v1
  up =. {{}. y , 0}}
  dn =. {{}: 0 , y}}
  lf =. {{}."1  y ,. 0}}
  rt =. {{}:"1 ]0 ,. y}}
  (y + up + dn + lf + rt + cn) gt     NB.!+v0
  (+ (up + dn + lf + rt + cn)@gt) y   NB.!+v1
)
#+end_src


gt itself is a function of y, and the result is operating on y,
so we can turn this last line into just a function composition applied to y.

** lift inner definitions
#+begin_src j
gt =: {{y > 3}}
up =: {{}. y , 0}}
dn =: {{}: 0 , y}}
lf =: {{}."1  y ,. 0}}
rt =: {{}:"1 ]0 ,. y}}
cn =: *&_4
settle =: monad define
  (+ (up + dn + lf + rt + cn)@gt) y
)
#+end_src


Now we can move all those function outside the definition of settle.
Settle itself is now a one line tacit verb applied to an argument, so that tacit verb can just be our definition of settle.

** explicit to tacit
#+begin_src j
gt =: {{y > 3}}
up =: {{}. y , 0}}
dn =: {{}: 0 , y}}
lf =: {{}."1  y ,. 0}}
rt =: {{}:"1 ]0 ,. y}}
cn =: *&_4
NB.!if v0
settle =: monad define
  (+ (up + dn + lf + rt + cn)@gt) y
)
NB.else
settle =: + (up + dn + lf + rt + cn)@gt
NB.end
#+end_src


So now we can make the final expression tacit, meaning we don't have to
refer to local variable y, and we're just directly constructing the verb
out of previously defined verbs.

* :reconcile
** compare to golfed version
#+begin_src j
settle =: + (up + dn + lf + rt + cn)@gt

NB.!if step>2
f =: _1 1 |.!.0"0 _ ]
s =: (++/@(_4&*,f,f&.(|:"2))@(3&<))^:_
NB.!end
#+end_src
When I wrote the golfed version, I didn't actually derive it this way. I just wrote it from scratch.
But, this line is pretty much the template that was in my head when I wrote it.
So let's compare the two:
** factor out s0
#+begin_src j
s =: (s0)^:_
s0 =: + +/@(_4&*,f,f&.(|:"2))@(3&<)
#+end_src

let's factor out s0

** compare again
#+begin_src j
s0 =: + +/@(_4&*,f,f&.(|:"2))@(3&<)    NB. for comparison
s1 =: +    (up+dn+lf+rt+cn)@gt         NB. settle

NB. we can re-arrange the terms a bit to make them line up

s1 =: +    (cn+up+dn+lf+rt)@gt         NB. by commutativity of +
s1 =: +    (_4&*+up+dn+lf+rt)@(3&<)    NB. inline cn and gt

s0 =: + +/@(_4&*,f,f&.(|:"2))@(3&<)    NB. for comparison

#+end_src
and now let's compare to our verb-in -progress
** u and v
#+begin_src j
u =: up,:dn                          NB. same as f
v =: lf,:rt                          NB. same as f&.(|:"2)
s1 =: + +/@(_4&*,u,v)@(3&<)          NB. we need to insert + between them

(s -: s1^:_) 50 50 $ 4               NB. result 1 means the two have the same output.
#+end_src
so s0 replaces the plus signs with commas, adds
the 'plus insert' outside, and replaces the
individual up down left right verbs with
the verb f and a modified version of f.
f is just doing the same as up,:dn
and this modified version of f -- f under transpose at rank 2
is the same as lf,:rt
** v under rank 2 transpose
#+begin_src j
u =: up,:dn                           NB. same as f
s1 =: + +/@(_4&*,u,u&.(|:"2))@(3&<)   NB. we need to insert + between them
(s -: s1^:_) 50 50 $ 4                NB. result 1 means the two have the same output.
#+end_src

if it's true that u and f are the same thing, then we ought to be able to get rid of
v, and therefore the lf and rt verbs, and just do the same thing in s1 for u that s0 does with f.

so let's try it.

** compare
#+begin_src j
up =: {{}. y , 0}}
dn =: {{}: 0 , y}}
u =: up,:dn
s0 =: + +/@(_4&*,f,f&.(|:"2))@(3&<)

f =: _1 1 |.!.0"0 _ ]
s1 =: + +/@(_4&*,u,u&.(|:"2))@(3&<)
#+end_src
now these two are exactly the same, except for the definitions of u and f
** back up: what does  &.(|:"2) actually do?
Okay, so let's back up and talk about what this &.(|:"2) means.
*** our shifting verbs
#+begin_src j
up =: {{ }.     y ,  0}}
dn =: {{ }:     0 ,  y}}
lf =: {{ }."1   y ,. 0}}
rt =: {{ }:"1 ] 0 ,. y}}
#+end_src

Here's what our four shifting verbs looked like before:

*** explicit ranks
#+begin_src j
up =: {{ }."_   y ,  0}}
dn =: {{ }:"_ ] 0 ,  y}}
lf =: {{ }."1   y ,. 0}}
rt =: {{ }:"1 ] 0 ,. y}}
#+end_src

On the left we have these two verbs, right curly dot and right curly colon.
Right curly dot is called "behead", and it removes the first item from a list.
Right curly colon is called "curtail", and it removes the last item from a list.

These operate at rank infinity, meaning they operate on the entire list at once.
So we can make that explicit with no change of meaning:


Note the use of the right identity for the down and right verbs.
This does nothing except separate the number on the left from the zero on the right.
Otherwise the two numbers would form a single token.

*** avoiding clutter
#+begin_src j
o =: 0
up =: {{ }."_  y ,"_  o}}
lf =: {{ }."1  y ,"1  o}}

dn =: {{ }:"_  o ,"_  y}}
rt =: {{ }:"1  o ,"1  y}}
#+end_src
Comma is called append.
Stitch is the same as comma at rank 1. *only when you're talking about 2d arrays*
So just to make this easier to read, I'm going to temporarily introduce a constant, o.
*** quick demo
#+begin_quote j
   m =: 5 5 $ _
   m
_ _ _ _ _
_ _ _ _ _
_ _ _ _ _
_ _ _ _ _
_ _ _ _ _
   (up;dn;lf;rt) m
┌─────────┬─────────┬─────────┬─────────┐
│_ _ _ _ _│0 0 0 0 0│_ _ _ _ 0│0 _ _ _ _│
│_ _ _ _ _│_ _ _ _ _│_ _ _ _ 0│0 _ _ _ _│
│_ _ _ _ _│_ _ _ _ _│_ _ _ _ 0│0 _ _ _ _│
│_ _ _ _ _│_ _ _ _ _│_ _ _ _ 0│0 _ _ _ _│
│0 0 0 0 0│_ _ _ _ _│_ _ _ _ 0│0 _ _ _ _│
└─────────┴─────────┴─────────┴─────────┘
#+end_quote


Anyway,now we can see that up and left are identical except for the rank
and dn and right are identical except for the rank.

Now you can never increase the rank of a verb. It doesn't really make any sense.
A verb that operates at rank 0 (on atoms) probably doesn't know how to work on lists.
(Especially lists of different shapes and sizes.)

But you *can* decrease the rank. So that means we can define
rt and lf in terms up up and down, but not vice versa.

That's probably okay because if we go back to the original definitions...

*** original definitions
#+begin_src j
up =: {{ }.     y ,  0}}
dn =: {{ }:     0 ,  y}}
lf =: {{ }."1   y ,. 0}}
rt =: {{ }:"1 ] 0 ,. y}}
#+end_src


...then up and down were the simpler choices.

*** simplifying with rank
#+begin_src j
up =: {{ }. y , 0 }}
dn =: {{ }: 0 , y }}
lf =: up"1
rt =: dn"1

u =: up,:dn
v =: lf,:rt        NB. this still works
NB. v =: up"1,:rt"1    NB. or this, but not (v =: u"1)
#+end_src
So one way we can do this is:
So that got rid of two of the definitions, but there
isn't a simple way to apply the "1 transformation
at each prong of the fork, rather than applying it
to the entire fork.
It's probably possible to use J's introspection capabilities
(5!:y) to write a conjunction that does such a thing, but as
far as I know, it's not built into J.
But in this case, it doesn't matter: there's a simple alternative.
*** using transpose instead
#+begin_src j
u =: up,:dn
v =:  |:&up&|:  ,:  |:&dn&|:        NB. transpose each side before and after
v =: (|:&up     ,:  |:&dn)&|:       NB. we can factor out the "before" part
v =: (|:"2)&( up ,: dn )&|:         NB. to factor out "after", we have to apply at rank 2 because it's now rank 3
v =: (|:"2)&(up,:dn)&(|:"2)         NB. it's safe to put rank 2 on the "before" part. now the before and after are the same.
v =: (up,:dn)&.(|:"2)               NB. now we can use "under"
v =: u&.(|:"2)

s1 =: + +/@(_4&*,u,v)@(3&<)
viewmat s1^:_ ] 50 50 $ 4
#+end_src
We can transpose the grid before and after:
Note: the important thing isn't that the before and after are the same,
it's that they're inverses of each other.
Removing the rank"2 here is a perfectly valid J program. It just isn't
the program we actually want.
*** inline v
#+begin_src j
s1 =: + +/@(_4&*,u,u&.(|:"2))@(3&<)
#+end_src

Anyway, now we can inline v:

** compare
#+begin_src j
up =: {{ }. y , 0}}
dn =: {{ }: 0 , y}}
u =: up,:dn

f =: _1 1 |.!.0"0 _ ]

s1 =: + +/@(_4&*,u,u&.(|:"2))@(3&<)
s0 =: + +/@(_4&*,f,f&.(|:"2))@(3&<)

(s -: s1^:_) 50 50 $ 4
#+end_src
Our definitions are now the same except for u vs f:
This is kind of a long expression, but it's not that complicated.
The core idea is the verb "rotate":
** rotate demo
#+begin_src j
   i. 3 3
0 1 2
3 4 5
6 7 8

   1 |. i. 3 3
3 4 5
6 7 8
0 1 2

   _1 |. i. 3 3
6 7 8
0 1 2
3 4 5
#+end_src
** rotate -> shift
#+begin_src j
   1 |.!._ i. 3 3
3 4 5
6 7 8
_ _ _
#+end_src

Rotate is one of a handful of primitive verbs that have variations
which would be really useful if you had a way to pass in one more
argument. Of course we do, and that's by using a conjunction. The
customize conjunction !. is just what we need.

Anyway, |.!.n means rotate, and fill with n. You can replace
the n with whatever you like.



In our case, we want 0.

So now we can re-implement up and dn in terms of shift:

** up and dn in terms of shift
#+begin_src j
up =: {{ }. y , 0 }}
dn =: {{ }: 0 , y }}

up =: {{ 1 |.!.0 y}}
dn =: {{_1 |.!.0 y}}
#+end_src
This is a longer definition, but it gives us some duplicate code we can factor out.
** tacit shift
#+begin_src j
up =:  1 |.!.0 ]
dn =: _1 |.!.0 ]
u =: up,:dn
#+end_src

First we can convert to tacit form:

** rotate rank
#+begin_src j
   |.b.0
_ 1 _
#+end_src

The rotate verb applies at rank 1 on the left and rank infinity on the right.


(The first number has to do with its use as a monad, which means reverse, then the
second two numbers indicate the rank at which the verb is applied to the left and
right arguments.)

So this means it's expecting a list on the left, and some arbitrary array on the right.
We want our list to mean "shift by these two amounts and return both results."
but as it happens, rotate is going to do something else. (We'll talk about what it
actually does in just a minute).

To make it do what we want (which is basically a simple for-each loop), we can just
adjust the rank

** and we're done!
#+begin_src j
u =: 1 _1 |.!.0"0 _ ]
f =: _1 1 |.!.0"0 _ ]
#+end_src



Now u and f are exactly the same except for the order, which,
since we're just summing the two versions, doesn't actually matter.

So now we've arrived at my golfed implementation of sandpiles.

* :golf
** TODO up,:dn as tacit dyad?
#+begin_src j
up =. {{ }. y , 0}}
dn =. {{ }: 0 , y}}
u =. up,:dn

f =: _1 1 |.!.0"0 _ ]
u =: 0&(}:@,,:}.@,~)
#+end_src
way smaller than old version and saves a charecter vs f

** jitwit's version
#+begin_src j
jw=:(+[:(_4&*+[:+/((,-)(,:|.)0 1)|.!.0])3&<)^:_     NB. jitwit's version
(s -: jw) 5 5 $ 4
#+end_src


This isn't how I arrived at it the first time. I pretty much had
the shape of the program in my head at the start.

This line, basically:

:  (+ (up + dn + lf + rt + cn)@gt) y

And I knew that the left and right versions would be the same as
up and down under transposition.

So basically, I probably started by just fiddling around in the j
shell to implement f, then probably wrote s the same way. Ususally
I'm testing my function out on some tiny array as I go along, so
I can make sure it does what I expect.

Anyway, I published that video, challenged anyone watching it to
try and produce a shorter version.

And someone rose to the challenge!

https://www.reddit.com/r/apljk/comments/fo472r/video_sandpiles_cellular_automata_in_j/fle394x?utm_source=share&utm_medium=web2x

)

** what's going on here?
#+begin_src j
sj =:(+ [: (_4&*+[:+/((,-)(,:|.)0 1)|.!.0]) 3&<)     NB. remove the ^:_

sj =: + [: (_4&*+[:+/((,-)(,:|.)0 1)|.!.0]) 3&<      NB. drop parens
NB.   _ __ ________________________________ ___    4 verbs
NB.   _ ___________________________   2 verbs
s0 =: + +/@(_4&*,f,f&.(|:"2))@(3&<)
#+end_src
In the console:
:   jw
: (+ ([: (_4&* + [: +/ (4 2$0 1 1 0 0 _1 _1 0) |.!.0 ]) 3&<))^:_
: )
There are some small differences in the way the verbs are composed.
Jitwit uses a train of 4 verbs compared to my 2. Either way, it's still
even numbered, which makes it a hook.
(except the [: changes how the fork is applied)
** left arguments to |.
So earlier I glossed over the left argument for shift and rotate.
The reason it looks at rank one for the left argument is because
each number in the list corresponds to an amount to shift on each axis.
so:
*** old
#+begin_src j
up =:  1 |.!.0 ]
dn =: _1 |.!.0 ]
u =: up,:dn
#+end_src

*** new
#+begin_src j
up =:  1 0 |.!.0 ]
dn =: _1 0 |.!.0 ]
lf =:  0 1 |.!.0 ]
rt =:  0 _1|.!.0 ]
u =: up,:dn
v =: lf,:rt
#+end_src

** all four at once
#+begin_src j
g =: u,v
g =: (1 0, _1 0, 0 1,: 0 _1) |.!.0 ]
s1 =: ++/@(_4&*,g)@(3&<)
(s -: s1^:_) 5 5 $ 4
#+end_src

But because it operates on rank 1, it means if you supply a rank 2 array
on the left, you get the "foreach" for free. So now we can drop the transpose,
and do all four at once:

** jitwit's trick
#+begin_src j
n =: 4 2$0 1 1 0 0 _1 _1 0
n =: 0 1, 1 0, 0 _1,: _1 0
n =: (,-)(,:|.)0 1
#+end_src

So jitwit's main trick is to generate that left argument concisely.
Or rather any permutation of that left argument.

Jitwit's version is in a slightly different order:



They've also re-arranged some things, replacing composition
with use of the verb cap, but it doesn't actually affect
the length:

** removing parens with cap
#+begin_src j
jw =: +[:(_4&*+[:+/n|.!.0])3&<
s1 =: ++/@(_4&*,n|.!.0])@(3&<)   NB. (f g@h)  <-->  (f[:g h)
s1 =: +[:+/@(_4&*,n|.!.0])3&<    NB. shaves off one character by swapping [: for @()
(s -: s1^:_) 5 5 $ 4
#+end_src

** compressing n
#+begin_src j
n =: (,-)(,:|.)0 1
n =: (,-)=/~i.2
n =: (,-)2]\i:1
#+end_src

Can we find a shorter definition of n, or any permutation of those rows?
I don't see a way to improve on (,-), but these shave off two
characters each:

** final golf
#+begin_src j
s1 =: +[:+/@(_4&*,((,-)2]\i:1)|.!.0])3&<
#+end_src


Picking the last version and inlining leaves us with the final golfed version:


If you can beat that, leave your code in a comment. :)

Of course, in the real world, I'd rather optimize for clarity.
And while I think a shorter program is often a better program,
adding code just to compress a string of numbers just makes
the reader do extra work.

** final program
#+begin_src j
load 'viewmat'
d =: 0 1, 1 0, 0 _1,: _1 0          NB. directions to shift
s =: + [: +/@(_4&*, d|.!.0]) 3&<    NB. sandpiles step
viewmat s^:_ [ 50 50 $ 4
#+end_src

So given what I know now, I'd probably write something like this:

** TODO more from jitwit:

: s1 =: +[:+/@(_4&*,((,-)2]\i:1)|.!.0])3&<
: ab =: -[:(4&*(-+/)((,-)=/~i.2)|.!.0])3&<

knocks another two characters off:

"and hinted at a second trick--avoid multiplication and instead
subtract from each shifted copy:"

: ab =: -[:+/@(-"2((,-)=/~i.2)|.!.0])3&<

* :wrapup
** TODO check out my channel for more j videos
