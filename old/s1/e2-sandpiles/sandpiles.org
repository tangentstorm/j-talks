#+title: sandpiles

* setup                                                         :stage:
#+begin_src j
erase_sandpaint_ nl_sandpaint_''
erase_sandpiles_ nl_sandpiles_''
erase_sandcalc_ nl_sandcalc_''
erase_gridpad_ nl_gridpad_''
cocurrent'base'

NB. have inheritance image positioned and minimized.
#+end_src

* demo
# on stage: the 512 grain-in-the-center sandpile, copied to buffer.
# pen =: 1, grid off, timer off, focus in window!
What you're looking at here is called a sandpile.
# toggle grid
It's a two dimensional grid.
Each square contains zero or more grains of sand, indicated by the color.

# start drawing
If you have 0, or 1, 2 or 3 grains of sand, the pile is stable.
But as soon as you get to four grains, the sand topples over
sending one grain to each of its four neighboring cells.

# draw by the edge
Now if you have a four next to the edge of the board,
the same thing happens,
but one of the grains falls off the edge.
# .. and corner
Similarly, if you have a four over in the corner, then two grains fall off.

# draw line of 3 at bottom
If you have a line of threes,
and put a four next to it,
then when that four topples,
it adds a grain to the three,
giving you a new four
and then that one topples,
you get a chain reaction.

# put mouse in center and press z to clear screen
And if you clear all this out and start with a bigger number,
(say 256),
then it will just keep pumping out four grains of sand at each step.

# space a few times until zthe four neighbors pile up
So after four ticks, we have four piles of four, plus 240 grains left in the center.
and all five of these are about to topple.
and the center just keeps pumping out more
and more
and more

# step until we get the diagonals
Now at this point we have four cells with with one grain each in them,
but each one has three neighbors that are about to topple.
So each of these ones will turn into a four.
# step
Also each time these four around the center topple,
the center is sending out four,
but each one of those is sending one back
so for that particular step in the process
the number in the center doesn't change.
# press 4

Anyway it goes on like that,
but before long the whole thing always winds down and comes to a stop.
# (fast forward)

If we did the same thing with 512 grains of sand
in the middle,
or we added another 256 grains here,
we'd get the picture that was
on the screen at the start.

So as you can see, with just this one simple rule,
you start generating really intricate patterns rather quickly.
and depending on how you start,
you might get a nice pretty picture like this one,
or
if you just start pouring sand
and fast forward
you might get a complete mess.

* intro
#+begin_src j
NB. (full screen cam)
#+end_src

Hi there.

My name's Michal, and this is my video about sandpiles.

Now that you know the basics of sandpiles,
we're going to take a quick look at how to
implement the rules on a computer.

We're also going to take a look at the original
paper to see why these were first invented.

Finally, we're going to look at some of the
interesting mathematics related to sandpiles,
while building this calculator program,
which also turns out to make a pretty good
puzzle game.

So I hope you stick around to the end because
I think I we're going to have a lot of fun.

Let's get started.

* sandpiles
#+begin_src j

NB. (title card: sandpiles)

#+end_src
** gridpad
#+begin_src j
load '~JTalks/s1/e2-sandpiles/gridpad.ijs'

gpw_init_gridpad_''
#+end_src

I made this little drawing program in a previous video,
and I'm going to reuse it here just so we have a nice
way to view and edit our sandpiles.

You don't need to have seen that video to understand
this one, but if you did see it, the basic ideas haven't
changed, but you might notice I've renamed some things
and refactored a bit, mostly breaking out configuration
variables. There's a link to a full changelog on github
in the video description.

Anyway, starting from what we have here, you're going to
see every line of code. And fair warning: most of you won't
be able to read it. I'm using J, and J is very terse and
it uses a lot of punctuation, but don't worry about that.

If you don't care about J or think it looks like a cat
walked over my keyboard, that's okay. I'm not going to
stop and explain the notation in this video, but I will
explain what it's doing.

What I really want to get across in this video is just
the flow of ideas - how to think with the building
blocks J gives us.

If this inspires you to implement something in your own
favorite language, I'd love to hear about it. Send me
a link in the comments!

But if you are learning J, or you're just convinced the
code I'm showing is an elaborate joke and want me to prove
it isn't, I am going to post a separate code review video
where I walk through each line.

So if you want to see that, or you just want to see more
videos like this, now's a great time to hit the subscribe button.

Meanwhile, on with the show.

** inheritance
#+begin_src j
cocurrent 'sandpiles'
coinsert 'gridpad'

cocurrent 'sandpaint'
coinsert 'sandpiles'

cocurrent 'sandcalc'
coinsert 'sandpiles'
#+end_src

This set up an inheritance hierarchy.

Normally these lines would be scattered across different files,
but I'm executing code directly off the slides so I'm just setting
things up from the start.

The word cocurrent switches the current locale, which is J's
term for a namespace, creating it if it doesn't already exist.

Then coinsert modifes the lookup path for names in a current locale.
It's kind of a freeform inheritance mechanism, and here I'm inheriting
entire applications and just overriding the parts I want to change.

So we'll put all the colors and the simulation logic into
this sandpiles application.

And these other two applications are going
to override and modify that in different ways.

** setup for next slide                                        :stage:
#+begin_src j
NB. hide terminal, run next window, bring to lower left quadrant.

#+end_src
** sandpiles window
#+begin_src j
cocurrent'sandpiles'

gpo_title =: 'sandpiles'
gpo_colorpick =: 0
gpo_palv_wh =: 50 480

gpw_init''
#+end_src

So we'll start by overriding the title,
turn off the ability to pick new colors,
and make the palette view a bit wider
so there's room to draw some labels.

Then =gpw_init= fires up our modified gridpad window.

** sandpile colors
#+begin_src j
cocurrent 'sandpiles'

pal =: 0 1 2 3, 2^2+i.16                        NB. the actual values to draw
pen =: 1

lo =: 16b00000f 16b3f3f9d 16b7878d8 16bacacff   NB. i.4 drawn as shades of blue
hi =: 16bff0000 + 16b001100 * i._16             NB. 4+i.204 are yellow..red
rgb =: lo,hi

NB. map any number of grains to rgb
to_rgb =: rgb {~ (<:#pal) <. pal I. ]

NB. map rgb colors back to the palette
shl =: 32 b. ~
to_pal =: pal {~ (#rgb) | rgb i. (1 shl 24)&|

#+end_src

This code sets up our colors.
: (run)
The palette isn't hooked up to the timer
so we click the window to make it repaint.

So the palette is just the raw numbers zero through four
and then 8, 16, 32, and so on.

The verb =to_rgb= maps numbers in the image
to one of those intervals.
For example, 11 falls between 8 and 16,
so we color it like an 8.

This part in the middle says that if the number is out of range, just
map it to the last entry.

Also, if you open a PNG file in here, =to_pal=
strips out the alpha channel then maps these exact colors
to those exact numbers. The part in the middle on this one
says map any other color to zero.

Again, if you want to know what all the symbols mean check
out the code review video. But for now, we have our colors,
so let's move on.

** palette labels
#+begin_src j
cocurrent 'sandpiles'

gpw_palv_paint =: verb define
  gpw_palv_paint0''                              NB. call original

  NB. draw text labels over the colors:
  glfont 'consolas 8'
  glpen 1 [ glbrush glrgb 0 0 0
  gltextcolor glrgb 255 255 255
  h =. {: palv_cellsize''
  for_n. pal do. i =. n_index
    if. i < 16 do. text =. ": n else. text =. '2^',":i-2 end.
    xx =. 25 - -: ww =.(8*#text)   NB. center text horizontally
    yy =. <.h*i+0.275              NB. vertically
    glrect xx, yy, (ww+1), 14
    gltextxy (2+xx),yy
    gltext text
  end.
)
#+end_src

This is the paint event handler for the palette view.

: run and click

It calls the original handler from gridpad,
and then does an expliict loop through the palette to draw labels.

** approaching the rules
#+begin_src j
cocurrent 'sandpiles'

gpw_char =: verb define  NB. key handler for imgv and palv controls.
  select. {. sysdata     NB. 'wasd' is ',aoe' on a dvorak keyboard :)
    case. '>' do. render img =: img > 3           NB. greater than 3
    case. ',' do. render img =: }. img , 0        NB. move up
    case. 'o' do. render img =: }: 0 , img        NB. move down
    case. 'a' do. render img =: }."1   img ,. 0   NB. move left
    case. 'e' do. render img =: }:"1 ] 0 ,. img   NB. move right
  end.
)
#+end_src

And now we get to the fun stuff.

This is the keyboard handler. I'm using it to define
some shortcuts to help us visualize the steps
of the sandpile simulation.

Let's say we have some arbitrary sandpile

: open face.png

... and we need to decide what's going to happen next in our simulation.

The rule is that any cell with 3 grains or fewer is stable,
so we only care about values greater than 3. So in this image,
all we want are the eyes and mouth and these little antennas
on top, and this border.

To isolate those, we can just compare the whole image to the number three.

: >

The basic comparision operators in J work on individual items, so
we wind up with a rank 2 array of zeros and ones.

So now this image represents one grain of sand for each cell that's going to topple.
And we just need to shift it over one slot
in each of the four directions.

That's what these other four lines do.

# show it

So a rank two array is basically a list of rows.
So to shift the image up, we add a row of zeros at the bottom and then chop off the first row.

To shift down, we add a row of zeros to the top
and chop off the bottom.

Then left and right work the same way, but they operate at the row level,
or rank 1.

We lost some sand along the way here because it fell off the edge.
To make sure we don't lose that information,
We just need to make a fresh copy before we nudge
in each direction.

Then all we have to do is take our four shifted copies and add them to the
original image, and then subtract to remove the four grains from the center.

** settle
#+begin_src j
cocurrent 'sandpiles'

settle =: monad define          NB. settle sandpiles with entries > 3
  gt =. y > 3
  up =. }.   gt ,  0            NB. shift in each of the 4 directions
  dn =. }:    0 ,  gt           NB. (filling in with 0 rather than wrapping)
  lf =. }."1 gt ,. 0
  rt =. }:"1 ]0 ,. gt
  cn =. _4 * gt                 NB. the 4 we subtract from the center
  y + up + dn + lf + rt + cn
)

update =: verb define
  img =: settle img
)
#+end_src

So here's what that looks like.

It's exactly what we just said, where y is the original image,
gt is the fresh copy we start with each time,
and we shift it up down left and right.
Then cn just multiplies it negative four.

Then result is all of that added back to the original image.

Then this update method is gridpad's hook to perform our animation,
so once I run this,
I can draw with sand and it topples in real time.

Okay, so that's the beginner way to write this in J.

If you're disappointed that this is too readable and easy to understand
and you were hoping for something more exotic to impress your friends
and terrify your enemies then I have just the thing for you.

* code golf
#+begin_src j
NB. (title card: code golf)
#+end_src
* golfed sandpile sim
#+begin_src j
load'viewmat'

f=:_1 1|.!.0"0 _]
s=:(++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

viewmat s 50 50$4
#+end_src

Here is a complete standalone J program
that fills a 50 by 50 grid with the number four,
runs the sandpile simulation until it stops,
and outputs the results.

** golfed sandpile sim (with color)
#+begin_src j
load'viewmat'

f=:_1 1|.!.0"0 _]
s=:(++/@(_4&*,f,f&.(|:"2))@(3&<))^:_

NB. was:     viewmat s 50 50$4
'rgb' viewmat to_rgb s 50 50$4
#+end_src

If you want our color scheme you can borrow =to_rgb=.

# run it

Btw, the title here says "golfed"...
Code golf is a game programmers play where you try to
express an idea in as few characters as possible, and
J is a favorite language among code golfers.

Actually, this is the shortest version of the sandpile
simulation I could think of, but it's also pretty much
the natural way to write it in J - at least for me.

The only thing I did to golf it was to remove
all the extra spaces.

Now if you have any interest at all in J, I encourage
you to download J and try this for yourself, and then
see if you can figure out how it works.

If you're realy brave, maybe you can come up with an
even shorter way to write it.

And again, I'll explain the entire line character by
character in the code review.

But now, back to our program.

* sandpaint
#+begin_src j
NB. (title card: sandpaint)
#+end_src
** sandpaint window
#+begin_src j
cocurrent 'sandpaint'

img =: 32 32 $ 0

gpo_title =: 'sandpaint'
gpo_timer =: 500
gpo_palv_wh =: 50 800
gpo_imgv_wh =: 800 800
gpo_gridrgb =: 0 0 0

gpw_init''

NB. move it on-camera:
wd 'pmove 900 100 0 0'
#+end_src

So here's the main code for sandpaint.
It just sets the window title and timer speed,
changes the size of the controls.

** time control
#+begin_src j
cocurrent 'sandpaint'

gpw_char =: verb define
  time_keys''
)

time_keys =: verb define
  select. {. sysdata
    case. ' ' do. gpw_timer [ wd'ptimer 0'          NB. space = single step
    case. '1' do. wd'ptimer 1000'                   NB. 1 = pretty slow
    case. '2' do. wd'ptimer 500'                    NB. ...
    case. '3' do. wd'ptimer 100'
    case. '4' do. wd'ptimer 50'
    case. '5' do. wd'ptimer 25'                     NB. ...
    case. '9' do. wd'ptimer 1'                      NB. 9 = fast as possible
    case. '0' do. wd'ptimer 0'                      NB. 0 = stop
  end.
)
#+end_src

Here's a first pass at the keyboard handler.

The event handler name for the timer
is windowname underscore timer so
setting ptimer 0 and then calling =gpw_timer= lets us fake
a timer event every time we press space.

The rest of these just run the clock at various speeds from
once a second when you press one, all the way up to once a
millisecond (or really just as fast as it can go)
when you press 9, and then zero stops it completely.

That's almost it for sandpaint. All that's left is to add a
few more shortcuts when we look at the original sandpile
paper. So let's do some science.

* sandpaper
#+begin_src j

NB. (title card: sandpaper)

cocurrent 'sandpaint'
wd'psel ',(":gpw_hwnd),'; ptimer 0'
pen =: 4
#+end_src
** DONE intro (anchorcam)

There have been a number of papers written about
the mathematical properties of sandpiles,
but it was actually a physics paper that introduced
them to the world.

# show the paper
It was called
_Self Organized Criticality: An Explanation of 1/f Noise_,

# show scholarpedia charts
Now 1/f noise (or pink noise) is the name for a phenomenon
that crops up in all sorts of seemingly unrelated fields,
from the level of rivers, to heart rates,
to fluctuations in electrical components.

It happened to be first identified
in vaccuum tubes in 1925.
But it was Benoit Mandelbrot
who pointed out how widespread
it was across different areas of science,
and his book, _The Fractal Geometry of Nature_,
which was published five years before the sandpile paper,
seems to have helped popularize the concept.

The best explanation I could find for what makes
1/f noise interesting actually comes from Mandelbrot
by way of Martin Gardner:

#+begin_quote text
Let the tape of a sound be played
faster or slower than normal.
One expects the character of the sound
to change considerably.

A violin, for example,
no longer sounds like a violin.

There is a special class of sounds, however,
that behave quite differently.

If you play a recording of such a sound
at a different speed, you only have
to adjust the volume to make it sound exactly
as before. Mandelbrot calls such sounds
"scaling noises".
#+end_quote

# show white/pink/brown chart
Gardner goes on to give three examples
of scaling noises:

white noise, where each value is completely random,

brown noise, where the value simply moves up or down at each step,

and pink noise, which is somewhere in between.

In particular, the spectral density plot of these noises
which is the bar chart what you'd see on your stereo's graphic
equalizer if you tried playing these patterns
as sound waves, each has a very distinct look.

This is what you'd see if you graphic equalizer made log-log plots.
Otherwise they look like this:

#+begin_src j
load'plot'
'keypos top right;key 1/f^0 1/f^1 1/f^2' plot % (0 1 2) ^~/ 1+i.10
#+end_src

If you look at these exponents, it's clear that in some sense,
1/f noise is halfway between white and brown noise.

The mystery is why would this somewhat random but self-similiar
scaling pattern crop up in so many places in nature?
What sort of physical mechanism would cause that?

And that's where sandpiles come in.

Now, I'm not going to pretend to fully understand this paper.
To be honest, even though its short
I think I understand the basic concepts,
some of the details were a little difficult
for me, I can't guarantee that everything
I say here is accurate, but I'll do my best.

** DONE physics simulation voiceover
The first part of the paper is an argument about connected systems in general. They give the example of how forces propagate through an array of pendula connected by springs. But the one dimensional case isn't terribly interesting - the energy just moves down the line.

I made a couple attempts to illustrate the point they were making
with a 2d array of pendula, but I didn't really have the right set of dimensions to work with in a 2d physics program, and even when I
replaced the pendula balls on springs and turned off gravity it's just really hard to tell what's going on in a physics simulation.

Thankfully the point the authors are making isn't tied to any particular system,
and they introduce sandpiles as an abstract model that's easy to simulate.

So let me attempt to make their point, as I understand it,
using the sandpile simulation.

** the sandpaper experiment
#+begin_src j
cocurrent 'sandpaint'

copy =: img

gpw_char =: verb define
  time_keys''
  NB. "Self-organized criticality: an explanation of 1/f noise"
  NB. Per Bak, Chao Tang, and Kurt Wiesenfeld
  select. {. sysdata
    case. 'u' do. render img =: 1 1 $ 0            NB. unit sandpile
    case. '7' do. render img =: 1 1 $ 7 + 4*20     NB. four score and 7
    case. '@' do. render img =: 32 32 $ 2          NB. @ = all 2
    case. '#' do. render img =: 32 32 $ 3          NB. # = all 3
    case. '$' do. render img =: 63 63 $ 4          NB. $ = all 4
    case. 'r' do. render img =: ? 32 32 $ 4        NB. r = random grid
    case. 'R' do. render img =: 4 + ? 100 100 $ 4  NB. R = big random grid
    case. 'f' do. render img =: settle^:_ img      NB. f = fast forward
    case. 'c' do. copy =: img                      NB. c = copy
    case. 'x' do. render 'img copy' =: copy;img    NB. x = swap
    case. '?' do. viewmat copy ~: img              NB. ? = show diff
  end.
)
#+end_src


The first concept is a minimally stable state.
Suppose you have the unit sandpile. ('u')
This is a 1x1 array with a single cell.

We can put any value we  like in here, but there's only four values that make it stable. Of course all the unstable values in our palette are multiples of four, so if we put any of those in there, it's going to wind down to zero.

But if we put a number like 87 in there, it settles down to 3.
Three is the minimally stable state for a sandpile in the sense that
you can be more stable, but you can't be less stable without actually toppling.

When we look at the system as a whole, especially a real system out in nature, we would be very surprised to find all the units in a minimally stable state.

Why not?

# show "all 3" configuration

Why? Well, the slightest disturbance at the edge sends a cascade of changes out through the system, and every single cell gets affected. Since nature is messy and complicated, we'd expect lots of small disturbances to happen, and so a uniform minimally stable state probably wouldn't last very long.

But as we encounter more and more disturbances, these areas of more stable cells start to build up, and they stop the noise from propagating. But every once in a while, a signal still gets through into one of these big areas.

And that's the key idea. As they write in the paper:

#+begin_src quote
The system will become stable precisely at the point when the network of minimally stable states has been broken down to the level where the noise signal cannot be communicated through infinite distances. At this point there will be no length scale in the problem so that one might expect the formation of a scale-invariant structure of minimally stable states.
#+end_src

In other words, since nothing we've discussed depends on the size of the system, there's no particular constraint on how big your connected island of threes is, so it shouldn't be a surprise that we get patches of all different sizes.

On the other hand, and this is just my interpretation, maybe the bigger patches near the outside are more likely to get hit, and therefore more likely to get broken down themselves, whereas big islands towards the center would be more protected, and so maybe something like this is what leads to the 1/f distribution of effects in nature.

Of course the argument is a lot less credible if it only works when everything starts in the minimally stable configuration, because then you have to explain why things start out that way.

# show "all 2", demonstrate that clicking does nothing.

Now if we started with all twos, it's already incredibly stable. You can nudge it all you want and it barely makes a dent.

And if we start with a stable configuration at random, it's also likely to remain stable. In a purely random configuration, there's no particular incentive for large areas of threes to form.

# press 0 $

The trick is to start with an unstable system. For example, here's a 63 by 63 grid of fours. (And by the way this is going to start strobing a bit so if you're sensitive to flashing lights you might want to look away for a moment.)

# press 9 and wait

Okay it's done... And you can see already that there are a bunch of different sizes of islands all around the edge.

So this is an example of what the authors call a critical state. It's stable, but large portions are only minimally stable. And the hypothesis put forth in the paper is that an interconnected system that starts out completely unstable will naturally wind down into one of these critical states, rather than one of the more stable configurations we saw earlier. Hence the phrase "self-organizing criticality."

So the next step was to test this hypothesis, and they did that on the computer, using the sandpile simulation.

Basically, they started with a big random grid of numbers slightly greater than three.

# press R

This takes forever to animate, and it's not especially interesting to look at, so let's fast forward.

So hopefully this is a sandpile in a critical state, but with everything so mixed up, it's not obvious how to tell.

It does look different from the random piles we saw before.

I press 'c' to copy this for a second, and then press 'r' to see a random stable grid. 'x' swaps back and forth.

Notice that almost all the black squares are isolated by themselves, and there seem to be way more twos and threes overall.

In fact, lets can look at it numerically.

: 'bar' plot >([: +/@|: (i.4)=/]) each img ;&, copy

So actually way more threes. Here are the counts from when we started with all fours for comparison.

: 'bar' plot 481 136 764 2588,~ >([: +/@|: (i.4)=/]) each img ;&, copy

Maybe there's something worth exploring in measurements like these, but getting back to the paper, the experiment went something like this.

- Generate a big unstable grid
- let it settle
- take a snapshot so we know the original state
- then set any one of the cells to four and let it play out.
- then compare the before and after images, record the size of the change

: +/+/ copy ~: img

Then they did this a bunch of times and recorded the results.

Now they're a little unclear on the details here. Did they keep hitting the same spot every time, and observe a progression, or was it different spots? And if it was different spots, did they reset the array each time?

Also notice there's some dark areas inside the perimiter, where cells might have been affected during the run but then settled back to their original values. They did include a graphic which shows them filled in, which makes me think they count.

So anyway, let's reproduce their experiment as best we can and see what happens.

Of course, rather than do that by hand, we'll let J do the work for us.

** the experiment
#+begin_src j
Note 'sandpaper setup'
  - full screen term window
  - 'desktop only' in obs
  - session font to consolas/24
)
open'~JTalks/s1/e2-sandpiles/sandpaper.ijs'
#+end_src

: work through the code there
: (splice in the animplot stuff)

: show final result vs their log-log plot.

So here's their results. Note that their graph only goes up to 1000,
so they're only looking at the central part anyway. They say this part
of the graph keeps smoothing out as you make the arrays bigger and bigger.

Even looking only at the middle,
I don't really understand what they did to get
a graph that smooth and close to the line.

Certainly my own plotting skills need some work,
especially in J, but it does look like the general
idea checks out.

Not only do unstable sandpiles settle down into critical
states that give rise to lots of different reaction sizes,
but those sizes tend to follow something close to a 1/f
distribution.

By the way, the bottom chart in the paper
came from running the same
kind of simulation in 3 dimensions. Presumably they
used cubes and distribute changes to six neighbors
instead of four. Maybe someone out there can make a
3d version in minecraft. If so, I'd love to see it. :)

Also, these charts on the right plot the distribution of
reaction lengths - as in the number of steps the reaction
took before settling down.

So they do address a 1/f distribution in the time dimension,
although it's still not clear to me how any of this maps
to one over f noise in a frequency spectrum.

Anyway, that's my take on the sandpaper. Like I said before,
it was kind of a stretch for me to get my head around all
that, so if I got anything wrong or just wasn't clear,
then by all means, please set me straight in the comments.

Meanwhile, let's shift gears from science to math,
and take a look at sandpile addition.

* sandcalc
#+begin_src j

NB. (title card: sandcalc)

#+end_src
** sandcalc
#+begin_src j
cocurrent 'sandcalc'
coinsert 'sandpiles gridpad'

gpo_title =: 'sandcalc - sandpile calculator'
gpo_timer =: 200
gpo_statusbar =: 0
gpo_colorpick =: 0
gpo_menu =: ''

gpw_init_controls =: verb define
  wd'bin h'
  wd' minwh  50 200; cc palv isigraph;'
  wd' minwh 200 200; cc sp0v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp1v isidraw;'
  wd' cc "+" static;'
  wd' minwh 200 200; cc sp2v isidraw;'
  wd' cc "=" static;'
  wd' minwh 200 200; cc sp3v isidraw;'
  wd'bin z'
)

render =: ]  NB. because there's no 'imgv' control

gpw_init''

#+end_src

Okay so here's a new window with four little sandpiles.

** sandcalc - render
#+begin_src j
cocurrent 'sandcalc'

pal =: i.4                      NB. limit to stable piles
pen =: 0                        NB. color to draw with

NxN =: 5 5
sp0 =: NxN $ 0
sp1 =: NxN $ 3
sp2 =: NxN $ 0

(update =: verb define)''
  sp3 =: settle^:_ sp0 + sp1 + sp2
)

render =: verb define
  vmcc sp0;'sp0v'
  vmcc sp1;'sp1v'
  vmcc sp2;'sp2v'
  vmcc sp3;'sp3v'
)

#+end_src

The animation here is just like before except we're going to
limit the palette to our four stable values, and on every
tick we're going to add the first three sandpiles together
let it settle, and show the result on the right.

** sandcalc - mouse
#+begin_src j
cocurrent 'sandcalc'

gpw_sp0v_mwheel =: gpw_sp1v_mwheel=: gpw_sp2v_mwheel=: gpw_palv_mwheel

NB. left click draws on the input
gpw_sp0v_mblup =: verb : 'sp0 =: sp0 img_draw whichbox 40'
gpw_sp1v_mblup =: verb : 'sp1 =: sp1 img_draw whichbox 40'
gpw_sp2v_mblup =: verb : 'sp2 =: sp2 img_draw whichbox 40'

NB. left drag does the same
gpw_sp0v_mmove =: verb : 'if. mbl _ do. gpw_sp0v_mblup _ end.'
gpw_sp1v_mmove =: verb : 'if. mbl _ do. gpw_sp1v_mblup _ end.'
gpw_sp2v_mmove =: verb : 'if. mbl _ do. gpw_sp2v_mblup _ end.'

NB. right click to copy the sum to an input
gpw_sp0v_mbrup =: verb : 'sp0 =: sp3'
gpw_sp1v_mbrup =: verb : 'sp1 =: sp3'
gpw_sp2v_mbrup =: verb : 'sp2 =: sp3'

NB. middle click to reset the input
gpw_sp0v_mbmup =: verb : 'sp0 =: NxN$0'
gpw_sp1v_mbmup =: verb : 'sp1 =: NxN$3'
gpw_sp2v_mbmup =: verb : 'sp2 =: ZSP'

ZSP =: NxN $ 0 NB. the trivial zero
#+end_src

We can draw in each of the first three just like
before.

Right clicking one of the inputs causes it to copy
the sum over, and middle clicking resets the input.

So for example,

: set middle to single square, leave others at 0

one plus one is two

right click to copy the two

one plus two is three

copy the three

one plus three is four

and of course the pile of four topples over.

One more time...

And that's how the plus sign was invented. :)

Once again, I'll explain all of this in the code review,
but I do want to point out these last few lines.

The middle click handler on sp0 (this left one) sets it to an array of all zeros.
Then sp1 is all threes, and sp2 is ZSP, which stands for zero sandpile.
And on the next line I've temporarily defined it as all zeros.

The reason I made a variable for this one
is that it's just a placeholder.

It turns out that when you add sandpiles
together, there's always at least one other
sandpile that acts like a zero.

Let's take a look.

** the zero sandpile
#+begin_src j
cocurrent 'sandpaint'

gpo_showgrid =: 1
gpo_gridrgb =: 3 $ 255

wd'psel ',(":gpw_hwnd)
wd'pmove 970 100 0 0; ptop; ptimer 0'

render img =: ((0,0,~])&.|:)@(0,0,~])^:8 ]  5 5 $ 4

#+end_src

I'm going to show you an algorithm for finding the other zero.

You start with an array of fours in the shape you want.

So here it's a five by five array of fours.
(This part just adds an a border of eight zeros around it.)

Then step through until it settles.

We can ignore the sand that fell off.

And now we're going to subtract each of these values from four.

The zeros become fours.

If we had any ones, we'd turn them into threes, but we don't.
And the twos stay the same.

And the threes turn into ones because four minus three is one.

Settle this one more time, and whatever's left is your zero.

...

Now before we try it out, let's set our expectations.

There's no way we could ever start from this zero and get
back to our simple plus sign, or even to the array of all zeros.

We can set any particular square to zero by figuring out what
you need to add to it to make four and letting it topple, but
every time you send a grain of sand off the edge, you're also
sending at least two grains back inward.

In fact if you think back to our random settled sandpile,
remember we noticed that all the zeros were isolated?

The evidence seems to suggest that it's just
plain impossible to get two empty squares next
to each other by adding sand. You have to create
them directly.

It seems like it ought to be possible to
prove that statement, and there are a bunch of math
papers about sandpiles, so maybe it's already been done,
but let's just call it a conjecture.

The point is there's nothing we're ever going to
add to this zero sandpile that's going to give us back
a completely empty sandpile.

So this new zero only works for some numbers. But
let's see what happens when we add it to our minimally
stable configuration.

: (draw it by hand)

And there we go. All threes plus this zero is all threes.

** the zero sandpile in j

#+begin_src j
cocurrent 'sandcalc'

stl =: settle^:_
ZSP =: stl (4 - stl) NxN $ 4

#+end_src

Okay so before we get too carried away, here's a restatement
of the algorithm to construct this thing in J.

Now we can draw whatever we want in the third slot
and middle click to set it back to ZSP.

If we set the other two sandpiles to all zeros,
it's obvious that adding these three together should
gives us ZSP. But also if we add three copies of ZSP
together, we get ZSP.

And by the way, that's not a commonly accepted name or anything.
It's just what I called it.

I actually first learned about Sandpiles from a really great
Numberphile video (which I've linked in the description),
and in which Dr. Luis David Garcia-Puente does a pretty
deep dive into the math of these zeros.

According to him, the set of sandpiles for which this zero works
is precisely the set you get by adding something to the array of
all threes. So that's why I put all threes in the middle.

So it turns out that if you take the set of sandpiles you get
from adding anything to the array of all threes, that set forms
a group under sandpile addition.

I don't know if it has a name, but given the original
paper, I think of it as the critical group.

** sandpiles under addition form an abelian group
#+begin_src j
cocurrent 'sandcalc'

O =: stl @: +

Note 'Definition of Group G with operation O'

 NB. Closure
 (*./(a,b) e. G) <: ((a O b) e. G)

 NB. Associativity
 (*./(a,b,c) e. G) <: ((a O b) O c) -: a O b O c

 NB. Identity element (e) (ZSP in our case)
 (a e. G) <: ((e O a) -: (a O e)) *. (a -: a O e)

 NB. Inverse elements  (I)
 (a e. G) <: (a O I a) -: e

)

Note 'Abelian Group'

  NB. Commutativity
  (*./(a,b) e. G) <: (a O b) -: (b O a)

)

#+end_src

When I say group, I mean a group in the mathematical sense,
which just means it follows these rules.

- the sum of two group members is a member
- it doesn't matter which order you add things in
- there's some identity element
- and for every element, there's an inverse element you can add to it to get the identity.

As it happens, it's also an Abelian group, so a + b is the same as b + a.

By the way, this slide is basically a docstring, but it is actual J syntax.

If we collected all the critical sandpiles into rank 3 array called G and we had a definition for this inverse function, then we could turn this into a verb and actually run it as a test case.

Generating G isn't that hard. You just list out all the five digit numbers in base four.

Of course the problem is that 4 to the 25th a huge number
so even if we packed them down to seven bytes each,
it would be like eight petabytes to store them all.

** all 2x2 stable sandpiles
#+begin_src j
cocurrent 'sandpaint'
800 160 gpw ,./^:2>16 16$([:<[:|:0,0,~[:|:0,0,~2 2$])"1](4$4)#:i.4^4

#+end_src

Just as an example, this line generates every possible two by two sandpile.
Again, it's just counting to 4 to the fourth power in base four and then
arranging them nicely.

So other than being completely impractical for bigger numbers,
it's not hard to generate all the sandpiles.

: go back one screen

But What about the inverse function?

Well, I was going to say I had no idea to do that,
but then I tried it and because I'm a super genius,
pretty much the first algorithm I though of worked.

** finding an inverse
#+begin_src j
cocurrent 'sandcalc'

e =: ZSP
O =: stl @: +

gpw_sp0v_char =: gpw_sp1v_char =:gpw_sp2v_char =: verb define
  select. {. sysdata
    case. 'i' do. render sp0 =: e - sp1     NB. left = "inverse" of middle
    case. 'a' do. render sp0 =: e O sp0     NB. add ZSP to left
    case. 'p' do. echo <sp0                 NB. print sp0
  end.
)
#+end_src

Except of course it doesn't actually work
because this is showing all zeros and
we know this should add up to all threes.

Of course it's just a display bug.
We have negative numbers in the grid
and that's not supposed to happen so
the coloring function doesn't account for it.

But it turns out if we just keep adding the zero
sandpile until the holes fill up, this approach
actually does work after all.

Again, I don't have a formal proof of that
statement, but as far as I can tell,
it always works.

** actual inverse
#+begin_src j
cocurrent 'sandcalc'

I =: [: e&O^:_ e - ]

gpw_sp0v_char =: gpw_sp1v_char =:gpw_sp2v_char =: verb define
  select. {. sysdata
    case. 'i' do. render sp0 =: I sp1          NB. left = inverse of middle
    case. 'a' do. render sp0 =: e O sp0        NB. add ZSP to left
    case. 'p' do. render sp1 =: 3 O ? NxN $ 4  NB. middle = random puzzle
  end.
)
#+end_src

However...

Even though it's easy to generate the inverse with a program,
it's not easy to guess what it's going to look like,
even if you know the algorithm.

That's why I said way back at the beginning
that this calculator doubles as puzzle game.

: reset all

For example, we just saw the inverse for all threes, but could you draw it from memory? I can't.

: just solve it live

So anyway, the random ones you get now by pressing p aren't nice and symmetric, which I think makes them quite a bit harder. Give it a shot yourself and let me know what you think.


Meanwhile, that's pretty much everything I have to say about sandpiles.

But I'll leave you now with what may be the most beautiful and profound equation in all of sandpile mathematics.

All threes.

All threes.

All threes.

And that, boys and girls, is where the plus sign really comes from.

* closing

Thank you so much for watching my video.

If you enjoyed it,
and you'd like to encourage me
to make more of these,
I'd really appreciate it you
shared the link with a friend.

And just a reminder,
if you want to learn what all those squiggly marks were about,
subscribe to this channel
and click the little bell icon
to get notified when the
code review comes out,

or if you prefer,
click here to join my mailing list
and I'll send you an email
whenever a new video comes out.

And by the way, if you don't want to wait,
all the code's already up on github
and there's a link to it down below,
along with links to the sandpile paper and
a bunch of other things related to
sandpiles that you might want to check out.

Finally, if you watched this video,
and you're not a programmer,
or you are a programmer
but have no interest whatsoever in learning J
then I'd really like to hear what you thought
of this video,
and in particular the style,
where you're seeing all the code but
not necessarily expected to understand it.

The next video I'm planning is on the Mandelbrot set,
and whether I split it into a general presentation
followed by a code review
or just do it all together
is probably going to depend on the response
I get to this one.

So please share your thoughts in the comments.
Let  me know what I could do to improve,
and feel free to ask questions
or if you make something related to sandpiles,
post a link.

I'd really love to hear from you.

Anyway, thanks again for watching,
and I hope to see you again.

* Video Description and Links

Code for this episode:
https://github.com/tangentstorm/j-talks/tree/master/s1/e2-sandpiles

Numberphile video on sandpiles with Dr Luis David Garcia-Puente:
https://www.youtube.com/watch?v=1MtEUErz7Gg

(The note about adding all 3's is at the 8:00 mark.)


Professor David Perkinson has a textbook on sandpile math, as well as interactive software:
http://people.reed.edu/~davidp/

Original sandpile paper:
http://cqb.pku.edu.cn/tanglab/pdf/1987-63.pdf

Sandpile math paper, including the algorithm to generate the "zero":
https://hal.archives-ouvertes.fr/hal-00016378

WikiZero on sandpiles:
https://www.wikizero.com/en/Sandpile

Code golf challenge with sandpiles in various languages:
https://codegolf.stackexchange.com/questions/92251/build-a-sandpile

J Vocabulary:
https://code.jsoftware.com/wiki/NuVoc

Download J from:
https://code.jsoftware.com/wiki/Guides/Getting_Started

